"""DatasetEvent creation parameters."""
input AddDatasetEventInput {
  """Dataset id"""
  datasetId: DatasetIdInput!

  """Dataset execution stage."""
  datasetStage: DatasetStage!

  """Dataset filename, if known."""
  filename: DatasetFilename
}

"""The result of adding a dataset event."""
type AddDatasetEventResult {
  """The new dataset event that was added."""
  event: DatasetEvent!
}

"""SequenceEvent creation parameters."""
input AddSequenceEventInput {
  visitId: VisitId!
  command: SequenceCommand!
}

"""The result of adding a sequence event."""
type AddSequenceEventResult {
  """The new sequence event that was added."""
  event: SequenceEvent!
}

"""StepEvent creation parameters."""
input AddStepEventInput {
  stepId: StepId!
  sequenceType: SequenceType!
  stepStage: StepStage!
}

"""The result of adding a step event."""
type AddStepEventResult {
  """The new step event that was added."""
  event: StepEvent!
}

input AirMassRangeInput {
  min: PosBigDecimal
  max: PosBigDecimal
}

type Allocation {
  partner: Partner!
  duration: TimeSpan!
}

"""
Create an angle from a signed value.  Choose exactly one of the available units.
"""
input AngleInput {
  microarcseconds: Long
  microseconds: BigDecimal
  milliarcseconds: BigDecimal
  milliseconds: BigDecimal
  arcseconds: BigDecimal
  seconds: BigDecimal
  arcminutes: BigDecimal
  minutes: BigDecimal
  degrees: BigDecimal
  hours: BigDecimal
  dms: String
  hms: String
}

interface Atom {
  id: AtomId!
  description: String
  observeClass: ObserveClass!
}

"""
AtomId id formatted as `a-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}`
"""
scalar AtomId

input BandBrightnessIntegratedInput {
  band: Band!
  value: BigDecimal
  units: BrightnessIntegratedUnits
  error: BigDecimal
}

input BandBrightnessSurfaceInput {
  band: Band!
  value: BigDecimal
  units: BrightnessSurfaceUnits
  error: BigDecimal
}

input BandNormalizedIntegratedInput {
  sed: UnnormalizedSedInput
  brightnesses: [BandBrightnessIntegratedInput!]
}

input BandNormalizedSurfaceInput {
  sed: UnnormalizedSedInput
  brightnesses: [BandBrightnessSurfaceInput!]
}

type Bias implements StepConfig {
  stepType: StepType!
}

enum Breakpoint {
  ENABLED
  DISABLED
}

input CatalogInfoInput {
  name: CatalogName
  id: NonEmptyString
  objectType: NonEmptyString
}

input ClassicalInput {
  minPercentTime: IntPercent
}

input CloneObservationInput {
  observationId: ObservationId!
  SET: ObservationPropertiesInput
}

type CloneObservationResult {
  originalObservation: Observation!
  newObservation: Observation!
}

input CloneTargetInput {
  targetId: TargetId!
  SET: TargetPropertiesInput
  REPLACE_IN: [ObservationId!]
}

type CloneTargetResult {
  originalTarget: Target!
  newTarget: Target!
}

input ConstraintSetInput {
  imageQuality: ImageQuality
  cloudExtinction: CloudExtinction
  skyBackground: SkyBackground
  waterVapor: WaterVapor
  elevationRange: ElevationRangeInput
}

scalar ChronicleId

scalar TransactionId

interface ChronicleEntry {
  id: ChronicleId!
  transactionId: TransactionId
  user: User
  timestamp: Timestamp!
}

type ConditionsEntry {
  id: ChronicleId!
  transactionId: TransactionId
  user: User
  timestamp: Timestamp!
  measurement: ConditionsMeasurement
  intuition: ConditionsIntuition
}

input ConditionsEntryInput {
  measurement: ConditionsMeasurementInput
  intuition: ConditionsIntuitionInput
}

"""Non-negative floating-point value."""
scalar Extinction

type ConditionsMeasurement {
  source: ConditionsMeasurementSource!
  seeing: Angle
  extinction: Extinction
  wavelength: Wavelength
  azimuth: Angle
  elevation: Angle
}

input ConditionsMeasurementInput {
  source: ConditionsMeasurementSource!
  seeing: AngleInput
  extinction: Extinction
  wavelength: WavelengthInput
  azimuth: AngleInput
  elevation: AngleInput
}

type ConditionsIntuition {
  expectation: ConditionsExpectation
  seeingTrend: SeeingTrend
}

input ConditionsIntuitionInput {
  expectation: ConditionsExpectationInput
  seeingTrend: SeeingTrend
}

type ConditionsExpectation {
  type: ConditionsExpectationType!
  timeframe: TimeSpan!
}

input ConditionsExpectationInput {
  type: ConditionsExpectationType!
  timeframe: TimeSpanInput!
}

type AddConditionsEntryResult {
  conditionsEntry: ConditionsEntry!
}

input CoordinatesInput {
  ra: RightAscensionInput
  dec: DeclinationInput
}

input CreateObservationInput {
  programId: ProgramId!
  SET: ObservationPropertiesInput
}

type CreateObservationResult {
  observation: Observation!
}

input CreateProgramInput {
  SET: ProgramPropertiesInput
}

type CreateProgramResult {
  program: Program!
}

input CreateTargetInput {
  programId: ProgramId!
  SET: TargetPropertiesInput!
}

type CreateTargetResult {
  target: Target!
}

type Dark implements StepConfig {
  stepType: StepType!
}

input DatasetPropertiesInput {
  qaState: DatasetQaState
}

input DeclinationInput {
  microarcseconds: Long
  degrees: BigDecimal
  dms: DmsString
}

input DeleteObservationsInput {
  WHERE: WhereObservation
  LIMIT: NonNegInt
}

type DeleteObservationsResult {
  observations: [Observation!]!
  hasMore: Boolean!
}

input DeleteTargetsInput {
  WHERE: WhereTarget
  LIMIT: NonNegInt
}

type DeleteTargetsResult {
  targets: [Target!]!
  hasMore: Boolean!
}

input DemoScienceInput {
  minPercentTime: IntPercent
}

input DirectorsTimeInput {
  minPercentTime: IntPercent
}

input EditAsterismsPatchInput {
  ADD: [TargetId!]
  DELETE: [TargetId!]
}

enum EditType {
  CREATED
  UPDATED
}

input ElevationRangeInput {
  airMass: AirMassRangeInput
  hourAngle: HourAngleRangeInput
}

input EmissionLineIntegratedInput {
  wavelength: WavelengthInput!
  lineWidth: PosBigDecimal
  lineFlux: LineFluxIntegratedInput
}

input EmissionLineSurfaceInput {
  wavelength: WavelengthInput!
  lineWidth: PosBigDecimal
  lineFlux: LineFluxSurfaceInput
}

input EmissionLinesIntegratedInput {
  lines: [EmissionLineIntegratedInput!]
  fluxDensityContinuum: FluxDensityContinuumIntegratedInput
}

input EmissionLinesSurfaceInput {
  lines: [EmissionLineSurfaceInput!]
  fluxDensityContinuum: FluxDensityContinuumSurfaceInput
}

input ExchangeInput {
  minPercentTime: IntPercent
}

input ExposureTimeModeInput {
  signalToNoise: SignalToNoiseModeInput
  fixedExposure: FixedExposureModeInput
}

input FastTurnaroundInput {
  minPercentTime: IntPercent
}

input FixedExposureModeInput {
  count: NonNegInt!
  time: TimeSpanInput!
}

input FluxDensity {
  wavelength: WavelengthInput!
  density: PosBigDecimal!
}

input FluxDensityContinuumIntegratedInput {
  value: PosBigDecimal!
  units: FluxDensityContinuumIntegratedUnits!
  error: PosBigDecimal
}

input FluxDensityContinuumSurfaceInput {
  value: PosBigDecimal!
  units: FluxDensityContinuumSurfaceUnits!
  error: PosBigDecimal
}

input GaussianInput {
  fwhm: AngleInput
  spectralDefinition: SpectralDefinitionIntegratedInput
}

type Gcal implements StepConfig {
  continuum: GcalContinuum
  arcs: [GcalArc!]!
  filter: GcalFilter!
  diffuser: GcalDiffuser!
  shutter: GcalShutter!
  stepType: StepType!
}

enum GcalArc {
  AR_ARC
  TH_AR_ARC
  CU_AR_ARC
  XE_ARC
}

enum GcalContinuum {
  IR_GREY_BODY_LOW
  IR_GREY_BODY_HIGH
  QUARTZ_HALOGEN5
  QUARTZ_HALOGEN100
}

enum GcalDiffuser {
  IR
  VISIBLE
}

enum GcalFilter {
  NONE
  GMOS
  HROS
  NIR
  ND10
  ND16
  ND20
  ND30
  ND40
  ND45
  ND50
}

enum GcalShutter {
  OPEN
  CLOSED
}

enum GmosAmpCount {
  THREE
  SIX
  TWELVE
}

type GmosCcdMode {
  xBin: GmosXBinning!
  yBin: GmosYBinning!
  ampCount: GmosAmpCount!
  ampGain: GmosAmpGain!
  ampReadMode: GmosAmpReadMode!
}

"""GMOS CCD readout input parameters"""
input GmosCcdModeInput {
  """X Binning, defaults to 'ONE'."""
  xBin: GmosXBinning

  """Y Binning, defaults to 'ONE'."""
  yBin: GmosYBinning

  """Amp Count, defaults to 'TWELVE'."""
  ampCount: GmosAmpCount

  """Amp Gain, defaults to 'LOW'"""
  ampGain: GmosAmpGain

  """Amp Read Mode, defaults to 'SLOW'"""
  ampRead: GmosAmpReadMode
}

type GmosCustomMask {
  filename: String!
  slitWidth: GmosCustomSlitWidth!
}

input GmosCustomMaskInput {
  filename: String!
  slitWidth: GmosCustomSlitWidth!
}

enum GmosCustomSlitWidth {
  CUSTOM_WIDTH_0_25
  CUSTOM_WIDTH_0_50
  CUSTOM_WIDTH_0_75
  CUSTOM_WIDTH_1_00
  CUSTOM_WIDTH_1_50
  CUSTOM_WIDTH_2_00
  CUSTOM_WIDTH_5_00
}

enum GmosDtax {
  MINUS_SIX
  MINUS_FIVE
  MINUS_FOUR
  MINUS_THREE
  MINUS_TWO
  MINUS_ONE
  ZERO
  ONE
  TWO
  THREE
  FOUR
  FIVE
  SIX
}

enum GmosEOffsetting {
  ON
  OFF
}

enum GmosGratingOrder {
  ZERO
  ONE
  TWO
}

type GmosNodAndShuffle {
  posA: Offset!
  posB: Offset!
  eOffset: GmosEOffsetting!
  shuffleOffset: Int!
  shuffleCycles: Int!
}

"""Creation input parameters for GMOS nod and shuffle"""
input GmosNodAndShuffleInput {
  """Offset position A"""
  posA: OffsetInput!

  """Offset position B"""
  posB: OffsetInput!

  """Electronic offsetting"""
  eOffset: GmosEOffsetting!

  """Shuffle offset"""
  shuffleOffset: PosInt!

  """Shuffle cycles"""
  shuffleCycles: PosInt!
}

type GmosNorthAtom implements Atom {
  id: AtomId!
  description: String
  observeClass: ObserveClass!
  steps: [GmosNorthStep!]!
}

"""GmosNorth Detector type"""
enum GmosNorthDetector {
  E2_V
  HAMAMATSU
}

type GmosNorthDynamic {
  exposure: TimeSpan!
  readout: GmosCcdMode!
  dtax: GmosDtax!
  roi: GmosRoi!
  gratingConfig: GmosNorthGratingConfig
  filter: GmosNorthFilter
  fpu: GmosNorthFpu
}

"""GMOS North instrument configuration input"""
input GmosNorthDynamicInput {
  """Exposure time"""
  exposure: TimeSpanInput!

  """GMOS CCD readout"""
  readout: GmosCcdModeInput!

  """GMOS detector x offset"""
  dtax: GmosDtax!

  """GMOS region of interest"""
  roi: GmosRoi!

  """GMOS North grating"""
  gratingConfig: GmosNorthGratingConfigInput

  """GMOS North filter"""
  filter: GmosNorthFilter

  """GMOS North FPU"""
  fpu: GmosNorthFpuInput
}

type GmosNorthExecutionConfig implements ExecutionConfig {
  gmosNorth: Boolean! @deprecated
  static: GmosNorthStatic!
  acquisition: GmosNorthExecutionSequence
  science: GmosNorthExecutionSequence
  instrument: Instrument!
  setup: SetupTime!
}

"""Next atom to execute and potential future atoms."""
type GmosNorthExecutionSequence implements ExecutionSequence {
  """Next atom to execute."""
  nextAtom: GmosNorthAtom!

  """(Prefix of the) remaining atoms to execute, if any."""
  possibleFuture: [GmosNorthAtom!]!

  """
  Whether there are more anticipated atoms than those that appear in
  'possibleFuture'.
  """
  hasMore: Boolean!

  """
  Total count of anticipated atoms, including 'nextAtom', 'possibleFuture' and
  any remaining atoms not included in 'possibleFuture'.
  """
  atomCount: PosInt!

  """
  Sequence digest (including all anticipated future values regardless of
  whether they appear in 'possibleFuture').
  """
  digest: SequenceDigest!
}

type GmosNorthFpu {
  customMask: GmosCustomMask
  builtin: GmosNorthBuiltinFpu
}

"""GMOS North FPU input parameters (choose custom or builtin)."""
input GmosNorthFpuInput {
  """Custom mask FPU option"""
  customMask: GmosCustomMaskInput

  """Builtin FPU option"""
  builtin: GmosNorthBuiltinFpu
}

type GmosNorthGratingConfig {
  grating: GmosNorthGrating!
  order: GmosGratingOrder!
  wavelength: Wavelength!
}

input GmosNorthGratingConfigInput {
  grating: GmosNorthGrating!
  order: GmosGratingOrder!
  wavelength: WavelengthInput!
}

input GmosNorthLongSlitInput {
  grating: GmosNorthGrating
  filter: GmosNorthFilter
  fpu: GmosNorthBuiltinFpu
  centralWavelength: WavelengthInput
  explicitXBin: GmosXBinning
  explicitYBin: GmosYBinning
  explicitAmpReadMode: GmosAmpReadMode
  explicitAmpGain: GmosAmpGain
  explicitRoi: GmosRoi
  explicitWavelengthDithers: [WavelengthDitherInput!]
  explicitSpatialOffsets: [OffsetComponentInput!]
}

enum GmosNorthStageMode {
  NO_FOLLOW
  FOLLOW_XYZ
  FOLLOW_XY
  FOLLOW_Z
}

type GmosNorthStatic {
  stageMode: GmosNorthStageMode!
  detector: GmosNorthDetector!
  mosPreImaging: MosPreImaging!
  nodAndShuffle: GmosNodAndShuffle
}

"""GMOS North static configuration input parameters"""
input GmosNorthStaticInput {
  """GMOS North Stage Mode (default to FOLLOW_XY)"""
  stageMode: GmosNorthStageMode

  """GMOS North Detector option (defaults to HAMAMATSU)"""
  detector: GmosNorthDetector

  """
  Whether this is a MOS pre-imaging observation (defaults to IS_NOT_MOS_PRE_IMAGING)
  """
  mosPreImaging: MosPreImaging

  """GMOS Nod And Shuffle configuration"""
  nodAndShuffle: GmosNodAndShuffleInput
}

type GmosNorthStep implements Step {
  instrumentConfig: GmosNorthDynamic!
  id: StepId!
  breakpoint: Breakpoint!
  stepConfig: StepConfig!
  estimate: StepEstimate!
  observeClass: ObserveClass!
}

type GmosNorthStepRecord {
  id: StepId!
  visitId: VisitId!
  created: Timestamp!
  startTime: Timestamp
  endTime: Timestamp
  duration: TimeSpan!
  instrumentConfig: GmosNorthDynamic!
  stepConfig: StepConfig!
  stepEvents: [StepEvent!]!
  stepQaState: StepQaState
  datasetEvents: [DatasetEvent!]!
  datasets: [Dataset!]!
}

type GmosNorthVisit {
  id: VisitId!
  created: Timestamp!
  startTime: Timestamp
  endTime: Timestamp
  duration: TimeSpan!
  static: GmosNorthStatic!
  steps: [GmosNorthStepRecord!]!
  sequenceEvents: [SequenceEvent!]!
}

type GmosSouthAtom implements Atom {
  id: AtomId!
  description: String
  observeClass: ObserveClass!
  steps: [GmosSouthStep!]!
}

"""GmosSouth Detector type"""
enum GmosSouthDetector {
  E2_V
  HAMAMATSU
}

type GmosSouthDynamic {
  exposure: TimeSpan!
  readout: GmosCcdMode!
  dtax: GmosDtax!
  roi: GmosRoi!
  gratingConfig: GmosSouthGratingConfig
  filter: GmosSouthFilter
  fpu: GmosSouthFpu
}

"""GMOS South instrument configuration input"""
input GmosSouthDynamicInput {
  """Exposure time"""
  exposure: TimeSpanInput!

  """GMOS CCD readout"""
  readout: GmosCcdModeInput!

  """GMOS detector x offset"""
  dtax: GmosDtax!

  """GMOS region of interest"""
  roi: GmosRoi!

  """GMOS South grating"""
  gratingConfig: GmosSouthGratingConfigInput

  """GMOS South filter"""
  filter: GmosSouthFilter

  """GMOS South FPU"""
  fpu: GmosSouthFpuInput
}

type GmosSouthExecutionConfig implements ExecutionConfig {
  gmosSouth: Boolean! @deprecated
  static: GmosSouthStatic!
  acquisition: GmosSouthExecutionSequence
  science: GmosSouthExecutionSequence
  instrument: Instrument!
  setup: SetupTime!
}

"""Next atom to execute and potential future atoms."""
type GmosSouthExecutionSequence implements ExecutionSequence {
  """Next atom to execute."""
  nextAtom: GmosSouthAtom!

  """(Prefix of the) remaining atoms to execute, if any."""
  possibleFuture: [GmosSouthAtom!]!

  """
  Whether there are more anticipated atoms than those that appear in
  'possibleFuture'.
  """
  hasMore: Boolean!

  """
  Total count of anticipated atoms, including 'nextAtom', 'possibleFuture' and
  any remaining atoms not included in 'possibleFuture'.
  """
  atomCount: PosInt!

  """
  Sequence digest (including all anticipated future values regardless of
  whether they appear in 'possibleFuture').
  """
  digest: SequenceDigest!
}

type GmosSouthFpu {
  customMask: GmosCustomMask
  builtin: GmosSouthBuiltinFpu
}

input GmosSouthFpuInput {
  customMask: GmosCustomMaskInput
  builtin: GmosSouthBuiltinFpu
}

type GmosSouthGratingConfig {
  grating: GmosSouthGrating!
  order: GmosGratingOrder!
  wavelength: Wavelength!
}

input GmosSouthGratingConfigInput {
  grating: GmosSouthGrating!
  order: GmosGratingOrder!
  wavelength: WavelengthInput!
}

input GmosSouthLongSlitInput {
  grating: GmosSouthGrating
  filter: GmosSouthFilter
  fpu: GmosSouthBuiltinFpu
  centralWavelength: WavelengthInput
  explicitXBin: GmosXBinning
  explicitYBin: GmosYBinning
  explicitAmpReadMode: GmosAmpReadMode
  explicitAmpGain: GmosAmpGain
  explicitRoi: GmosRoi
  explicitWavelengthDithers: [WavelengthDitherInput!]
  explicitSpatialOffsets: [OffsetComponentInput!]
}

enum GmosSouthStageMode {
  NO_FOLLOW
  FOLLOW_XYZ
  FOLLOW_XY
  FOLLOW_Z
}

"""Unchanging (over the course of the sequence) configuration values"""
type GmosSouthStatic {
  """Stage mode"""
  stageMode: GmosSouthStageMode!

  """Detector in use (always HAMAMATSU for recent and new observations)"""
  detector: GmosSouthDetector!

  """Is MOS Pre-Imaging Observation"""
  mosPreImaging: MosPreImaging!

  """Nod-and-shuffle configuration"""
  nodAndShuffle: GmosNodAndShuffle
}

"""GMOS South static configuration input parameters"""
input GmosSouthStaticInput {
  """GMOS South Stage Mode (defaults to FOLLOW_XYZ)"""
  stageMode: GmosSouthStageMode

  """GMOS South Detector option (defaults to HAMAMATSU)"""
  detector: GmosSouthDetector

  """
  Whether this is a MOS pre-imaging observation (defaults to IS_NOT_MOS_PRE_IMAGING)
  """
  mosPreImaging: MosPreImaging

  """GMOS Nod And Shuffle configuration"""
  nodAndShuffle: GmosNodAndShuffleInput
}

type GmosSouthStep implements Step {
  instrumentConfig: GmosSouthDynamic!
  id: StepId!
  breakpoint: Breakpoint!
  stepConfig: StepConfig!
  estimate: StepEstimate!
  observeClass: ObserveClass!
}

type GmosSouthStepRecord {
  id: StepId!
  visitId: VisitId!
  created: Timestamp!
  startTime: Timestamp
  endTime: Timestamp
  duration: TimeSpan!
  instrumentConfig: GmosSouthDynamic!
  stepConfig: StepConfig!
  stepEvents: [StepEvent!]!
  stepQaState: StepQaState
  datasetEvents: [DatasetEvent!]!
  datasets: [Dataset!]!
}

type GmosSouthVisit {
  id: VisitId!
  created: Timestamp!
  startTime: Timestamp
  endTime: Timestamp
  duration: TimeSpan
  static: GmosSouthStatic!
  steps: [GmosSouthStepRecord!]!
  sequenceEvents: [SequenceEvent!]!
}

"""Whether guiding is enabled for a particular science step."""
enum GuideState {
  """Guiding enabled."""
  ENABLED

  """Guiding disabled."""
  DISABLED
}

input HourAngleRangeInput {
  minHours: BigDecimal
  maxHours: BigDecimal
}

input IntensiveInput {
  minPercentTime: IntPercent
  minPercentTotalTime: IntPercent
  totalTime: TimeSpanInput
}

input LargeProgramInput {
  minPercentTime: IntPercent
  minPercentTotalTime: IntPercent
  totalTime: TimeSpanInput
}

input LineFluxIntegratedInput {
  value: PosBigDecimal!
  units: LineFluxIntegratedUnits!
}

input LineFluxSurfaceInput {
  value: PosBigDecimal!
  units: LineFluxSurfaceUnits!
}

"""Link user"""
input LinkUserInput {
  """The program to add a user to."""
  programId: ProgramId!

  """The user to be added."""
  userId: UserId!

  """The role this user will play in the program."""
  role: ProgramUserRole!

  """Must be specified if and only if 'role' is SUPPORT"""
  supportType: ProgramUserSupportRoleType

  """Must be specified if and only if 'supportType' is PARTNER"""
  supportPartner: Partner
}

type LinkUserResult {
  user: ProgramUser!
}

enum MosPreImaging {
  IS_MOS_PRE_IMAGING
  IS_NOT_MOS_PRE_IMAGING
}

type Mutation {
  addConditionsEntry(input: ConditionsEntryInput): AddConditionsEntryResult!

  """
  Adds a new dataset event associated with the given visit.  The
  generation of a single dataset will produce multiple events as it
  transitions through the observe, readout and write stages.
  """
  addDatasetEvent(
    """
    Describes the dataset event to add.  All events are associated with a
    particular visit (see 'record{InstrumentName}Visit').  Dataset events
    are further associated with an observation, step and index because a
    step may produce multiple datasets. (See also 'record{InstrumentName}Step'.)
    """
    input: AddDatasetEventInput!
  ): AddDatasetEventResult!

  """
  Adds a sequence event associated with the given visit. Multiple events
  will be produced during the execution of a sequence as it is started,
  paused, continued, etc.
  """
  addSequenceEvent(
    """
    Describes the sequence event to add.  All events are associated with a
    particular visit (see 'record{InstrumentName}Visit').  Sequence events
    are further associated with an observation.  Each sequence event identifies
    the sequence command that acted upon the sequence.
    """
    input: AddSequenceEventInput!
  ): AddSequenceEventResult!

  """
  Adds a new step event associated with the given step. Multiple events
  will be produced during the execution of a single step as it
  transitions through configure and observe stages.
  """
  addStepEvent(
    """
    Describes the step event to add.  All events are associated with a
    particular step (see 'record{InstrumentName}Step'. Each step event
    identifies the sequence type (acquisition or science) and the stage
    through which the step execution is passing.
    """
    input: AddStepEventInput!
  ): AddStepEventResult!
  cloneObservation(input: CloneObservationInput!): CloneObservationResult!
  cloneTarget(input: CloneTargetInput!): CloneTargetResult!

  """Creates a new observation according to provided parameters."""
  createGroup(
    """Group description."""
    input: CreateGroupInput!
  ): CreateGroupResult!
  createObservation(input: CreateObservationInput!): CreateObservationResult!
  createProgram(input: CreateProgramInput!): CreateProgramResult!
  createTarget(input: CreateTargetInput!): CreateTargetResult!
  deleteObservations(input: DeleteObservationsInput!): DeleteObservationsResult!
  deleteTargets(input: DeleteTargetsInput!): DeleteTargetsResult!

  """
  Link a user to a program. Any existing link will be replaced.
  This operation is available only to Admin and Service users.
  """
  linkUser(input: LinkUserInput!): LinkUserResult!

  """Record a new GMOS North step"""
  recordGmosNorthStep(
    """GmosNorth step configuration parameters"""
    input: RecordGmosNorthStepInput!
  ): RecordGmosNorthStepResult!

  """Record a new GMOS North visit"""
  recordGmosNorthVisit(
    """Visit creation parameters"""
    input: RecordGmosNorthVisitInput!
  ): RecordGmosNorthVisitResult!

  """Record a new GMOS South step"""
  recordGmosSouthStep(
    """GmosSouth step configuration parameters"""
    input: RecordGmosSouthStepInput!
  ): RecordGmosSouthStepResult!

  """Record a new GMOS South visit"""
  recordGmosSouthVisit(
    """Visit creation parameters"""
    input: RecordGmosSouthVisitInput!
  ): RecordGmosSouthVisitResult!

  """Set the allocation for a program from the specified partner."""
  setAllocation(input: SetAllocationInput!): SetAllocationResult!
  undeleteObservations(input: UndeleteObservationsInput!): UndeleteObservationsResult!
  undeleteTargets(input: UndeleteTargetsInput!): UndeleteTargetsResult!

  """
  Unlink a user from a program.
  This operation is available only to Admin and Service users.
  """
  unlinkUser(
    """The program to unlink the user from."""
    programId: ProgramId!

    """The user to unlink."""
    userId: UserId!
  ): UnlinkUserResult!
  updateAsterisms(input: UpdateAsterismsInput!): UpdateAsterismsResult!
  updateDatasets(input: UpdateDatasetsInput!): UpdateDatasetsResult!
  updateGroups(input: UpdateGroupsInput!): UpdateGroupsResult!
  updateObsAttachments(input: UpdateObsAttachmentsInput!): UpdateObsAttachmentsResult!
  updateObservations(input: UpdateObservationsInput!): UpdateObservationsResult!
  updatePrograms(input: UpdateProgramsInput!): UpdateProgramsResult!
  updateProposalAttachments(input: UpdateProposalAttachmentsInput!): UpdateProposalAttachmentsResult!
  updateTargets(input: UpdateTargetsInput!): UpdateTargetsResult!
}

input NonsiderealInput {
  keyType: EphemerisKeyType
  des: NonEmptyString
  key: NonEmptyString
}

type ObservationEdit {
  editType: EditType!
  value: Observation!
  id: Long! @deprecated(reason: "id is no longer computed; a constant value is returned")
}

input ObservationPropertiesInput {
  subtitle: NonEmptyString
  status: ObsStatus
  activeStatus: ObsActiveStatus
  visualizationTime: Timestamp
  posAngleConstraint: PosAngleConstraintInput
  targetEnvironment: TargetEnvironmentInput
  constraintSet: ConstraintSetInput
  timingWindows: [TimingWindowInput!]
  obsAttachments: [ObsAttachmentId!]
  scienceRequirements: ScienceRequirementsInput
  observingMode: ObservingModeInput
  existence: Existence
  groupId: GroupId
  groupIndex: NonNegShort
}

type Offset {
  p: OffsetP!
  q: OffsetQ!
}

"""
Offset component (p or q) input parameters. Choose one angle units definition.
"""
input OffsetComponentInput {
  """Angle in µas"""
  microarcseconds: Long

  """Angle in mas"""
  milliarcseconds: BigDecimal

  """Angle in arcsec"""
  arcseconds: BigDecimal
}

"""Offset input.  Define offset in p and q."""
input OffsetInput {
  """Offset in p"""
  p: OffsetComponentInput!

  """Offset in q"""
  q: OffsetComponentInput!
}

input ParallaxInput {
  microarcseconds: Long
  milliarcseconds: BigDecimal
}

type PartnerMeta {
  tag: Partner!
  shortName: String!
  longName: String!
  active: Boolean!
}

input PartnerSplitInput {
  partner: Partner!
  percent: IntPercent!
}

input PoorWeatherInput {
  minPercentTime: IntPercent
}

input PosAngleConstraintInput {
  mode: PosAngleConstraintMode
  angle: AngleInput
}

scalar PosLong

type ProgramEdit {
  editType: EditType!
  value: Program!
  id: Long! @deprecated(reason: "id is no longer computed; a constant value is returned")
}

input ProgramPropertiesInput {
  name: NonEmptyString
  proposal: ProposalInput
  existence: Existence
}

enum ProgramUserRole {
  """Co-Investigator"""
  COI

  """Observer (read-only access)"""
  OBSERVER

  """Staff/Partner Support"""
  SUPPORT
}

enum ProgramUserSupportRoleType {
  """Staff support"""
  STAFF

  """Partner support"""
  PARTNER
}

type ProgramUser {
  role: ProgramUserRole!
  userId: UserId!
  user: User
}

input ProperMotionComponentInput {
  microarcsecondsPerYear: Long
  milliarcsecondsPerYear: BigDecimal
}

input ProperMotionInput {
  ra: ProperMotionComponentInput!
  dec: ProperMotionComponentInput!
}

input ProposalClassInput {
  classical: ClassicalInput
  demoScience: DemoScienceInput
  directorsTime: DirectorsTimeInput
  exchange: ExchangeInput
  fastTurnaround: FastTurnaroundInput
  poorWeather: PoorWeatherInput
  queue: QueueInput
  systemVerification: SystemVerificationInput
  largeProgram: LargeProgramInput
  intensive: IntensiveInput
}

input ProposalInput {
  title: NonEmptyString
  proposalClass: ProposalClassInput
  category: TacCategory
  toOActivation: ToOActivation
  abstract: NonEmptyString
  partnerSplits: [PartnerSplitInput!]
}

input QueueInput {
  minPercentTime: IntPercent
}

input RadialVelocityInput {
  centimetersPerSecond: Long
  metersPerSecond: BigDecimal
  kilometersPerSecond: BigDecimal
}

"""Input parameters for creating a new GmosNorth StepRecord"""
input RecordGmosNorthStepInput {
  visitId: VisitId!
  instrument: GmosNorthDynamicInput!
  stepConfig: StepConfigInput!
}

type RecordGmosNorthStepResult {
  stepRecord: GmosNorthStepRecord!
}

"""Input parameters for creating a new GmosNorthVisit"""
input RecordGmosNorthVisitInput {
  observationId: ObservationId!
  static: GmosNorthStaticInput!
}

type RecordGmosNorthVisitResult {
  visit: GmosNorthVisit!
}

input RecordGmosSouthStepInput {
  visitId: VisitId!
  instrument: GmosSouthDynamicInput!
  stepConfig: StepConfigInput!
}

type RecordGmosSouthStepResult {
  stepRecord: GmosSouthStepRecord!
}

"""Input parameters for creating a new GmosSouthVisit"""
input RecordGmosSouthVisitInput {
  observationId: ObservationId!
  static: GmosSouthStaticInput!
}

type RecordGmosSouthVisitResult {
  visit: GmosSouthVisit!
}

input RightAscensionInput {
  microarcseconds: Long
  microseconds: Long
  degrees: BigDecimal
  hours: BigDecimal
  hms: HmsString
}

type Science implements StepConfig {
  offset: Offset!

  """Guide State (whether guiding is enabled for this step)"""
  guiding: GuideState!

  """Step type is always SCIENCE."""
  stepType: StepType!
}

"""
Which kind of smart gcal configuration is requested in a smart gcal step.
"""
enum SmartGcalType {
  ARC
  FLAT
  DAY_BASELINE
  NIGHT_BASELINE
}

"""SmartGcal step configuration."""
type SmartGcal implements StepConfig {
  smartGcalType: SmartGcalType!

  """Step type is always SMART_GCAL."""
  stepType: StepType!
}

input ObservingModeInput {
  gmosNorthLongSlit: GmosNorthLongSlitInput
  gmosSouthLongSlit: GmosSouthLongSlitInput
}

input ScienceRequirementsInput {
  mode: ScienceMode
  spectroscopy: SpectroscopyScienceRequirementsInput
}

input SetAllocationInput {
  programId: ProgramId!
  partner: Partner!
  duration: TimeSpanInput!
}

type SetAllocationResult {
  allocation: Allocation!
}

type SetupTime {
  full: TimeSpan!
  reacquisition: TimeSpan!
}

input SiderealInput {
  ra: RightAscensionInput
  dec: DeclinationInput
  epoch: EpochString
  properMotion: ProperMotionInput
  radialVelocity: RadialVelocityInput
  parallax: ParallaxInput
  catalogInfo: CatalogInfoInput
}

input SignalToNoiseModeInput {
  value: SignalToNoise!
}

input SourceProfileInput {
  point: SpectralDefinitionIntegratedInput
  uniform: SpectralDefinitionSurfaceInput
  gaussian: GaussianInput
}

input SpectralDefinitionIntegratedInput {
  bandNormalized: BandNormalizedIntegratedInput
  emissionLines: EmissionLinesIntegratedInput
}

input SpectralDefinitionSurfaceInput {
  bandNormalized: BandNormalizedSurfaceInput
  emissionLines: EmissionLinesSurfaceInput
}

input SpectroscopyScienceRequirementsInput {
  wavelength: WavelengthInput
  resolution: PosInt
  signalToNoise: SignalToNoise
  signalToNoiseAt: WavelengthInput
  wavelengthCoverage: WavelengthInput
  focalPlane: FocalPlane
  focalPlaneAngle: AngleInput
  capability: SpectroscopyCapabilities
}

interface Step {
  id: StepId!
  breakpoint: Breakpoint!
  stepConfig: StepConfig!
  estimate: StepEstimate!
  observeClass: ObserveClass!
}

interface StepConfig {
  stepType: StepType!
}

"""Step configuration.  Choose exactly one step type."""
input StepConfigInput {
  """Bias step creation option"""
  bias: Boolean

  """Dark step creation option"""
  dark: Boolean

  """GCAL step creation option"""
  gcal: StepConfigGcalInput

  """Science step creation option"""
  science: StepConfigScienceInput

  """Smart gcal creation option"""
  smartGcal: StepConfigSmartGcalInput
}

"""
GCAL configuration creation input.  Specify either one or more arcs or else
one continuum.
"""
input StepConfigGcalInput {
  arcs: [GcalArc!]
  continuum: GcalContinuum
  diffuser: GcalDiffuser!
  filter: GcalFilter!
  shutter: GcalShutter!
}

"""Science step creation input"""
input StepConfigScienceInput {
  offset: OffsetInput!

  """Whether guiding is enabled for this step (defaults to 'ENABLED')."""
  guiding: GuideState
}

"""SmartGcal step creation input"""
input StepConfigSmartGcalInput {
  smartGcalType: SmartGcalType!
}

enum StepQaState {
  PASS
  FAIL
}

enum StepType {
  BIAS
  DARK
  GCAL
  SCIENCE
  SMART_GCAL
}

type Subscription {
  observationEdit(input: ObservationEditInput): ObservationEdit!
  programEdit(input: ProgramEditInput): ProgramEdit!
  targetEdit(input: TargetEditInput): TargetEdit!
  groupEdit(input: GroupEditInput): GroupEdit!
}

input TargetEditInput {
  targetId: TargetId
  programId: ProgramId
}

input GroupEditInput {
  groupId: GroupId
  programId: ProgramId
}

input ObservationEditInput {
  observationId: ObservationId
  programId: ProgramId
}

input ProgramEditInput {
  programId: ProgramId
}

input SystemVerificationInput {
  minPercentTime: IntPercent
}

type TargetEdit {
  editType: EditType!
  value: Target!
  id: Long! @deprecated(reason: "id is no longer computed; a constant value is returned")
}

type GroupEdit {
  editType: EditType!
  value: Group!
  id: Long! @deprecated(reason: "id is no longer computed; a constant value is returned")
}

input TargetEnvironmentInput {
  explicitBase: CoordinatesInput
  asterism: [TargetId!]
}

input TargetPropertiesInput {
  name: NonEmptyString
  sidereal: SiderealInput
  nonsidereal: NonsiderealInput
  sourceProfile: SourceProfileInput
  existence: Existence
}

input TimingWindowRepeatInput {
  period: TimeSpanInput!
  times: PosInt
}

input TimingWindowEndInput {
  atUtc: Timestamp
  after: TimeSpanInput
  repeat: TimingWindowRepeatInput
}

input TimingWindowInput {
  inclusion: TimingWindowInclusion!
  startUtc: Timestamp!
  end: TimingWindowEndInput
}

input UndeleteObservationsInput {
  WHERE: WhereObservation
  LIMIT: NonNegInt
}

type UndeleteObservationsResult {
  observations: [Observation!]!
  hasMore: Boolean!
}

input UndeleteTargetsInput {
  WHERE: WhereTarget
  LIMIT: NonNegInt
}

type UndeleteTargetsResult {
  targets: [Target!]!
  hasMore: Boolean!
}

input UnnormalizedSedInput {
  stellarLibrary: StellarLibrarySpectrum
  coolStar: CoolStarTemperature
  galaxy: GalaxySpectrum
  planet: PlanetSpectrum
  quasar: QuasarSpectrum
  hiiRegion: HiiRegionSpectrum
  planetaryNebula: PlanetaryNebulaSpectrum
  powerLaw: BigDecimal
  blackBodyTempK: PosInt
  fluxDensities: [FluxDensity!]
}

input UpdateAsterismsInput {
  programId: ProgramId!
  SET: EditAsterismsPatchInput!
  WHERE: WhereObservation
  LIMIT: NonNegInt
  includeDeleted: Boolean = false
}

type UpdateAsterismsResult {
  observations: [Observation!]!
  hasMore: Boolean!
}

input UpdateObsAttachmentsInput {
  programId: ProgramId!
  SET: ObsAttachmentPropertiesInput!
  WHERE: WhereObsAttachment
  LIMIT: NonNegInt
}

type UpdateObsAttachmentsResult {
  obsAttachments: [ObsAttachment!]!
  hasMore: Boolean!
}

input UpdateDatasetsInput {
  SET: DatasetPropertiesInput!
  WHERE: WhereDataset
  LIMIT: NonNegInt
}

type UpdateDatasetsResult {
  datasets: [Dataset!]!
  hasMore: Boolean!
}

input UpdateGroupsInput {
  SET: GroupPropertiesInput!
  WHERE: WhereGroup
  LIMIT: NonNegInt
}

type UpdateGroupsResult {
  groups: [Group!]!
  hasMore: Boolean!
}

input UpdateObservationsInput {
  programId: ProgramId!
  SET: ObservationPropertiesInput!
  WHERE: WhereObservation
  LIMIT: NonNegInt
  includeDeleted: Boolean = false
}

type UpdateObservationsResult {
  observations: [Observation!]!
  hasMore: Boolean!
}

input UpdateProgramsInput {
  SET: ProgramPropertiesInput!
  WHERE: WhereProgram
  LIMIT: NonNegInt
  includeDeleted: Boolean = false
}

type UpdateProgramsResult {
  programs: [Program!]!
  hasMore: Boolean!
}

input UpdateProposalAttachmentsInput {
  programId: ProgramId!
  SET: ProposalAttachmentPropertiesInput!
  WHERE: WhereProposalAttachment
  LIMIT: NonNegInt
}

type UpdateProposalAttachmentsResult {
  proposalAttachments: [ProposalAttachment!]!
  hasMore: Boolean!
}

input UpdateTargetsInput {
  SET: TargetPropertiesInput!
  WHERE: WhereTarget
  LIMIT: NonNegInt
  includeDeleted: Boolean = false
}

type UpdateTargetsResult {
  targets: [Target!]!
  hasMore: Boolean!
}

input WavelengthInput {
  picometers: PosInt
  angstroms: PosBigDecimal
  nanometers: PosBigDecimal
  micrometers: PosBigDecimal
}

input WavelengthDitherInput {
  picometers: Int
  angstroms: BigDecimal
  nanometers: BigDecimal
  micrometers: BigDecimal
}

type OffsetP {
  microarcseconds: Long!
  milliarcseconds: BigDecimal!
  arcseconds: BigDecimal!
}

type AirMassRange {
  min: PosBigDecimal!
  max: PosBigDecimal!
}

type Angle {
  microarcseconds: Long!
  microseconds: BigDecimal!
  milliarcseconds: BigDecimal!
  milliseconds: BigDecimal!
  arcseconds: BigDecimal!
  seconds: BigDecimal!
  arcminutes: BigDecimal!
  minutes: BigDecimal!
  degrees: BigDecimal!
  hours: BigDecimal!
  hms: String!
  dms: String!
}

type AsterismGroup {
  program: Program!
  observations(includeDeleted: Boolean! = false, OFFSET: ObservationId, LIMIT: NonNegInt): ObservationSelectResult!
  asterism: [Target!]!
}

type AsterismGroupSelectResult {
  matches: [AsterismGroup!]!
  hasMore: Boolean!
}

scalar ObsAttachmentId

type ObsAttachment {
  id: ObsAttachmentId!
  attachmentType: ObsAttachmentType!
  fileName: NonEmptyString!
  description: NonEmptyString
  checked: Boolean!
  fileSize: Long!
  updatedAt: Timestamp!
  program: Program!
}

input ObsAttachmentPropertiesInput {
  description: NonEmptyString
  checked: Boolean
}

type ObsAttachmentFileExt {
  fileExtension: NonEmptyString!
}

type ObsAttachmentTypeMeta {
  tag: ObsAttachmentType!
  shortName: String!
  longName: String!
  fileExtensions: [ObsAttachmentFileExt!]!
}

enum Band {
  SLOAN_U
  SLOAN_G
  SLOAN_R
  SLOAN_I
  SLOAN_Z
  U
  B
  V
  R
  I
  Y
  J
  H
  K
  L
  M
  N
  Q
  AP
  GAIA
  GAIA_BP
  GAIA_RP
}

type BandBrightnessIntegrated {
  band: Band!
  value: BigDecimal!
  units: BrightnessIntegratedUnits!
  error: BigDecimal
}

type BandBrightnessSurface {
  band: Band!
  value: BigDecimal!
  units: BrightnessSurfaceUnits!
  error: BigDecimal
}

interface BandNormalized {
  sed: UnnormalizedSed
}

type BandNormalizedIntegrated implements BandNormalized {
  brightnesses: [BandBrightnessIntegrated!]!
  sed: UnnormalizedSed
}

type BandNormalizedSurface implements BandNormalized {
  brightnesses: [BandBrightnessSurface!]!
  sed: UnnormalizedSed
}

enum BrightnessIntegratedUnits {
  VEGA_MAGNITUDE
  AB_MAGNITUDE
  JANSKY
  W_PER_M_SQUARED_PER_UM
  ERG_PER_S_PER_CM_SQUARED_PER_A
  ERG_PER_S_PER_CM_SQUARED_PER_HZ
}

enum BrightnessSurfaceUnits {
  VEGA_MAG_PER_ARCSEC_SQUARED
  AB_MAG_PER_ARCSEC_SQUARED
  JY_PER_ARCSEC_SQUARED
  W_PER_M_SQUARED_PER_UM_PER_ARCSEC_SQUARED
  ERG_PER_S_PER_CM_SQUARED_PER_A_PER_ARCSEC_SQUARED
  ERG_PER_S_PER_CM_SQUARED_PER_HZ_PER_ARCSEC_SQUARED
}

type CatalogInfo {
  name: CatalogName!
  id: String!
  objectType: String
}

enum CatalogName {
  SIMBAD
  IMPORT
  GAIA
}

enum ChargeClass {
  NON_CHARGED
  PARTNER
  PROGRAM
}

type Classical implements ProposalClass {
  minPercentTime: IntPercent!
}

enum CloudExtinction {
  POINT_ONE
  POINT_THREE
  POINT_FIVE
  ONE_POINT_ZERO
  ONE_POINT_FIVE
  TWO_POINT_ZERO
  THREE_POINT_ZERO
}

enum ObservingModeType {
  GMOS_NORTH_LONG_SLIT
  GMOS_SOUTH_LONG_SLIT
}

type ConstraintSet {
  imageQuality: ImageQuality!
  cloudExtinction: CloudExtinction!
  skyBackground: SkyBackground!
  waterVapor: WaterVapor!
  elevationRange: ElevationRange!
}

type ConstraintSetGroup {
  observations(includeDeleted: Boolean! = false, OFFSET: ObservationId, LIMIT: NonNegInt): ObservationSelectResult!
  constraintSet: ConstraintSet!
}

type ConstraintSetGroupSelectResult {
  matches: [ConstraintSetGroup!]!
  hasMore: Boolean!
}

enum CoolStarTemperature {
  T400_K
  T600_K
  T800_K
  T900_K
  T1000_K
  T1200_K
  T1400_K
  T1600_K
  T1800_K
  T2000_K
  T2200_K
  T2400_K
  T2600_K
  T2800_K
}

type Coordinates {
  ra: RightAscension!
  dec: Declination!
}

type Dataset {
  observation: Observation!
  id: DatasetId!
  filename: DatasetFilename!
  qaState: DatasetQaState
}

"""
Dataset-level events.  A single dataset will be associated with multiple events
as it makes its way through observe, readout and write stages.
"""
type DatasetEvent {
  """Event id."""
  id: ExecutionEventId!

  """Identifies the associated dataset."""
  datasetId: DatasetId!

  """Associated visit."""
  visitId: VisitId!

  """Dataset filename, when known."""
  filename: DatasetFilename

  """Dataset execution stage."""
  datasetStage: DatasetStage!

  """Observation whose execution produced this event."""
  observation: Observation!

  """Time at which this event was received."""
  received: Timestamp!
}

"""Dataset filename in standard format."""
scalar DatasetFilename

type DatasetId {
  """Step ID."""
  stepId: StepId!

  """Dataset index."""
  index: NonNegShort!
}

input DatasetIdInput {
  """Step ID."""
  stepId: StepId!

  """Dataset index."""
  index: NonNegShort!
}

enum DatasetQaState {
  PASS
  USABLE
  FAIL
}

type DatasetSelectResult {
  matches: [Dataset!]!
  hasMore: Boolean!
}

"""Execution stage or phase of an individual dataset."""
enum DatasetStage {
  END_OBSERVE
  END_READOUT
  END_WRITE
  START_OBSERVE
  START_READOUT
  START_WRITE
}

type Declination {
  dms: DmsString!
  degrees: BigDecimal!
  microarcseconds: Long!
}

type DemoScience implements ProposalClass {
  minPercentTime: IntPercent!
}

type DirectorsTime implements ProposalClass {
  minPercentTime: IntPercent!
}

scalar DmsString

type TimeSpan {
  microseconds: Long!
  milliseconds: BigDecimal!
  seconds: BigDecimal!
  minutes: BigDecimal!
  hours: BigDecimal!
  iso: String!
}

input TimeSpanInput {
  microseconds: Long
  milliseconds: BigDecimal
  seconds: BigDecimal
  minutes: BigDecimal
  hours: BigDecimal
  iso: String
}

type ElevationRange {
  airMass: AirMassRange
  hourAngle: HourAngleRange
}

type EmissionLineIntegrated {
  wavelength: Wavelength!
  lineWidth: PosBigDecimal!
  lineFlux: LineFluxIntegrated!
}

type EmissionLineSurface {
  wavelength: Wavelength!
  lineWidth: PosBigDecimal!
  lineFlux: LineFluxSurface!
}

type EmissionLinesIntegrated {
  lines: [EmissionLineIntegrated!]!
  fluxDensityContinuum: FluxDensityContinuumIntegrated!
}

type EmissionLinesSurface {
  lines: [EmissionLineSurface!]!
  fluxDensityContinuum: FluxDensityContinuumSurface!
}

enum EphemerisKeyType {
  COMET
  ASTEROID_NEW
  ASTEROID_OLD
  MAJOR_BODY
  USER_SUPPLIED
}

scalar EpochString

type Exchange implements ProposalClass {
  minPercentTime: IntPercent!
}

type Execution {
  datasets(OFFSET: DatasetIdInput, LIMIT: NonNegInt): DatasetSelectResult!
  events(OFFSET: ExecutionEventId, LIMIT: NonNegInt): ExecutionEventSelectResult!
  executionConfig: ExecutionConfig!
}

interface ExecutionConfig {
  instrument: Instrument!
  setup: SetupTime!
}

interface ExecutionEvent {
  id: ExecutionEventId!
  visitId: VisitId!
  observation: Observation!
  received: Timestamp!
}

"""ExecutionEventId id formatted as `e-[1-9a-f][0-9a-f]*`"""
scalar ExecutionEventId

type ExecutionEventSelectResult {
  matches: [ExecutionEvent!]!
  hasMore: Boolean!
}

enum Existence {
  PRESENT
  DELETED
}

interface ExecutionSequence {
  digest: SequenceDigest!
}

type ExposureTimeMode {
  signalToNoise: SignalToNoiseMode
  fixedExposure: FixedExposureMode
}

type FastTurnaround implements ProposalClass {
  minPercentTime: IntPercent!
}

type FilterTypeMeta {
  tag: FilterType!
  shortName: String!
  longName: String!
}

type FixedExposureMode {
  count: NonNegInt!
  time: TimeSpan!
}

type FluxDensityContinuumIntegrated {
  value: PosBigDecimal!
  units: FluxDensityContinuumIntegratedUnits!
  error: PosBigDecimal
}

enum FluxDensityContinuumIntegratedUnits {
  W_PER_M_SQUARED_PER_UM
  ERG_PER_S_PER_CM_SQUARED_PER_A
}

type FluxDensityContinuumSurface {
  value: PosBigDecimal!
  units: FluxDensityContinuumSurfaceUnits!
  error: PosBigDecimal
}

enum FluxDensityContinuumSurfaceUnits {
  W_PER_M_SQUARED_PER_UM_PER_ARCSEC_SQUARED
  ERG_PER_S_PER_CM_SQUARED_PER_A_PER_ARCSEC_SQUARED
}

type FluxDensityEntry {
  wavelength: Wavelength!
  density: PosBigDecimal!
}

enum FocalPlane {
  SINGLE_SLIT
  MULTIPLE_SLIT
  IFU
}

enum GalaxySpectrum {
  ELLIPTICAL
  SPIRAL
}

type GaussianSource {
  fwhm: Angle!
  bandNormalized: BandNormalizedIntegrated
  emissionLines: EmissionLinesIntegrated
}

enum GmosAmpGain {
  LOW
  HIGH
}

enum GmosAmpReadMode {
  SLOW
  FAST
}

enum GmosNorthBuiltinFpu {
  NS0
  NS1
  NS2
  NS3
  NS4
  NS5
  LONG_SLIT_0_25
  LONG_SLIT_0_50
  LONG_SLIT_0_75
  LONG_SLIT_1_00
  LONG_SLIT_1_50
  LONG_SLIT_2_00
  LONG_SLIT_5_00
  IFU2_SLITS
  IFU_BLUE
  IFU_RED
}

enum GmosNorthFilter {
  G_PRIME
  R_PRIME
  I_PRIME
  Z_PRIME
  Z
  Y
  GG455
  OG515
  RG610
  CA_T
  HA
  HA_C
  DS920
  SII
  OIII
  OIIIC
  HE_II
  HE_IIC
  HARTMANN_A_R_PRIME
  HARTMANN_B_R_PRIME
  G_PRIME_GG455
  G_PRIME_OG515
  R_PRIME_RG610
  I_PRIME_CA_T
  Z_PRIME_CA_T
  U_PRIME
}

enum GmosNorthGrating {
  B1200_G5301
  R831_G5302
  B600_G5303
  B600_G5307
  R600_G5304
  B480_G5309
  R400_G5305
  R150_G5306
  R150_G5308
}

type GmosNorthLongSlit {
  grating: GmosNorthGrating!
  filter: GmosNorthFilter
  fpu: GmosNorthBuiltinFpu!
  centralWavelength: Wavelength!
  xBin: GmosXBinning!
  defaultXBin: GmosXBinning!
  explicitXBin: GmosXBinning
  yBin: GmosYBinning!
  defaultYBin: GmosYBinning!
  explicitYBin: GmosYBinning
  ampReadMode: GmosAmpReadMode!
  defaultAmpReadMode: GmosAmpReadMode!
  explicitAmpReadMode: GmosAmpReadMode
  ampGain: GmosAmpGain!
  defaultAmpGain: GmosAmpGain!
  explicitAmpGain: GmosAmpGain
  roi: GmosRoi!
  defaultRoi: GmosRoi!
  explicitRoi: GmosRoi
  wavelengthDithers: [WavelengthDither!]!
  defaultWavelengthDithers: [WavelengthDither!]!
  explicitWavelengthDithers: [WavelengthDither!]
  spatialOffsets: [OffsetQ!]!
  defaultSpatialOffsets: [OffsetQ!]!
  explicitSpatialOffsets: [OffsetQ!]
  initialGrating: GmosNorthGrating!
  initialFilter: GmosNorthFilter
  initialFpu: GmosNorthBuiltinFpu!
  initialCentralWavelength: Wavelength!
}

enum GmosRoi {
  FULL_FRAME
  CCD2
  CENTRAL_SPECTRUM
  CENTRAL_STAMP
  TOP_SPECTRUM
  BOTTOM_SPECTRUM
  CUSTOM
}

enum GmosSouthBuiltinFpu {
  BHROS
  NS1
  NS2
  NS3
  NS4
  NS5
  LONG_SLIT_0_25
  LONG_SLIT_0_50
  LONG_SLIT_0_75
  LONG_SLIT_1_00
  LONG_SLIT_1_50
  LONG_SLIT_2_00
  LONG_SLIT_5_00
  IFU2_SLITS
  IFU_BLUE
  IFU_RED
  IFU_NS2_SLITS
  IFU_NS_BLUE
  IFU_NS_RED
}

enum GmosSouthFilter {
  U_PRIME
  G_PRIME
  R_PRIME
  I_PRIME
  Z_PRIME
  Z
  Y
  GG455
  OG515
  RG610
  RG780
  CA_T
  HARTMANN_A_R_PRIME
  HARTMANN_B_R_PRIME
  G_PRIME_GG455
  G_PRIME_OG515
  R_PRIME_RG610
  I_PRIME_RG780
  I_PRIME_CA_T
  Z_PRIME_CA_T
  HA
  SII
  HA_C
  OIII
  OIIIC
  HE_II
  HE_IIC
  LYA395
}

enum GmosSouthGrating {
  B1200_G5321
  R831_G5322
  B600_G5323
  R600_G5324
  B480_G5327
  R400_G5325
  R150_G5326
}

type GmosSouthLongSlit {
  grating: GmosSouthGrating!
  filter: GmosSouthFilter
  fpu: GmosSouthBuiltinFpu!
  centralWavelength: Wavelength!
  xBin: GmosXBinning!
  defaultXBin: GmosXBinning!
  explicitXBin: GmosXBinning
  yBin: GmosYBinning!
  defaultYBin: GmosYBinning!
  explicitYBin: GmosYBinning
  ampReadMode: GmosAmpReadMode!
  defaultAmpReadMode: GmosAmpReadMode!
  explicitAmpReadMode: GmosAmpReadMode
  ampGain: GmosAmpGain!
  defaultAmpGain: GmosAmpGain!
  explicitAmpGain: GmosAmpGain
  roi: GmosRoi!
  defaultRoi: GmosRoi!
  explicitRoi: GmosRoi
  wavelengthDithers: [WavelengthDither!]!
  defaultWavelengthDithers: [WavelengthDither!]!
  explicitWavelengthDithers: [WavelengthDither!]
  spatialOffsets: [OffsetQ!]!
  defaultSpatialOffsets: [OffsetQ!]!
  explicitSpatialOffsets: [OffsetQ!]
  initialGrating: GmosSouthGrating!
  initialFilter: GmosSouthFilter
  initialFpu: GmosSouthBuiltinFpu!
  initialCentralWavelength: Wavelength!
}

enum GmosXBinning {
  ONE
  TWO
  FOUR
}

enum GmosYBinning {
  ONE
  TWO
  FOUR
}

"""A group of observations and other groups."""
type Group {
  id: GroupId!

  """Optionally, a name"""
  name: String

  """Optionally, a description."""
  description: String

  """
  How many do we need to complete? If this is null then it means we have to complete them all
  """
  minimumRequired: NonNegShort

  """Do they need to be completed in order?"""
  ordered: Boolean!

  """
  Is there a minimum required and/or maximum allowed timespan between observations?
  """
  minimumInterval: TimeSpan
  maximumInterval: TimeSpan

  """Contained elements"""
  elements: [GroupElement!]!
}

scalar GroupId

"""
Groups contain observations and other groups. Exactly one will be defined.
"""
type GroupElement {
  parentGroupId: GroupId
  parentIndex: NonNegShort!
  group: Group
  observation: Observation
}

input GroupPropertiesInput {
  """Group name (optional)."""
  name: NonEmptyString

  """Group description (optional)."""
  description: NonEmptyString

  """
  Minimum number of elements to be observed. If unspecified then all elements will be observed.
  """
  minimumRequired: NonNegShort

  """
  If true, elements will be observed in order. Defaults to false if left unspecified.
  """
  ordered: Boolean

  """
  If specified, elements will be separated by at least `minimumInterval`.
  """
  minimumInterval: TimeSpanInput

  """If specified, elements will be separated by at most `maximumInterval`."""
  maximumInterval: TimeSpanInput

  """
  Parent group (optional). If specified then parent index must also be specified.
  """
  parentGroup: GroupId

  """
  Parent index. If unspecified then the element will appear first in the program or parent group (if specified). Cannot be set to null.
  """
  parentGroupIndex: NonNegShort
}

input CreateGroupInput {
  programId: ProgramId!
  SET: GroupPropertiesInput
}

"""The result of creating a new group."""
type CreateGroupResult {
  """The newly created group."""
  group: Group!
}

enum HiiRegionSpectrum {
  ORION_NEBULA
}

scalar HmsString

type HourAngleRange {
  minHours: BigDecimal!
  maxHours: BigDecimal!
}

enum ImageQuality {
  POINT_ONE
  POINT_TWO
  POINT_THREE
  POINT_FOUR
  POINT_SIX
  POINT_EIGHT
  ONE_POINT_ZERO
  ONE_POINT_FIVE
  TWO_POINT_ZERO
}

scalar Timestamp

enum Instrument {
  ACQ_CAM
  BHROS
  FLAMINGOS2
  GHOST
  GMOS_NORTH
  GMOS_SOUTH
  GNIRS
  GPI
  GSAOI
  MICHELLE
  NICI
  NIFS
  NIRI
  PHOENIX
  TRECS
  VISITOR
  SCORPIO
  ALOPEKE
  ZORRO
}

scalar IntPercent

type Intensive implements ProposalClass {
  minPercentTime: IntPercent!
  minPercentTotalTime: IntPercent!
  totalTime: TimeSpan!
}

type ItcResultSet {
  result: ItcResult!
  all: [ItcResult!]
}

type ItcResult {
  targetId: TargetId!
  exposureTime: TimeSpan!
  exposures: NonNegInt!
  signalToNoise: SignalToNoise!
}

type LargeProgram implements ProposalClass {
  minPercentTime: IntPercent!
  minPercentTotalTime: IntPercent!
  totalTime: TimeSpan!
}

type LineFluxIntegrated {
  value: PosBigDecimal!
  units: LineFluxIntegratedUnits!
}

enum LineFluxIntegratedUnits {
  W_PER_M_SQUARED
  ERG_PER_S_PER_CM_SQUARED
}

type LineFluxSurface {
  value: PosBigDecimal!
  units: LineFluxSurfaceUnits!
}

enum LineFluxSurfaceUnits {
  W_PER_M_SQUARED_PER_ARCSEC_SQUARED
  ERG_PER_S_PER_CM_SQUARED_PER_ARCSEC_SQUARED
}

scalar NonEmptyString

scalar NonNegBigDecimal

scalar NonNegShort

scalar NonNegInt

scalar NonNegLong

type Nonsidereal {
  des: String!
  keyType: EphemerisKeyType!
  key: String!
}

enum ObsActiveStatus {
  ACTIVE
  INACTIVE
}

enum ObsStatus {
  NEW
  INCLUDED
  PROPOSED
  APPROVED
  FOR_REVIEW
  READY
  ONGOING
  OBSERVED
}

enum TimingWindowInclusion {
  INCLUDE
  EXCLUDE
}

type TimingWindowRepeat {
  period: TimeSpan!
  times: PosInt
}

type TimingWindowEndAt {
  atUtc: Timestamp!
}

type TimingWindowEndAfter {
  after: TimeSpan!
  repeat: TimingWindowRepeat
}

union TimingWindowEnd = TimingWindowEndAt | TimingWindowEndAfter

type TimingWindow {
  inclusion: TimingWindowInclusion!
  startUtc: Timestamp!
  end: TimingWindowEnd
}

type Observation {
  id: ObservationId!
  existence: Existence!
  title: String!
  subtitle: NonEmptyString
  status: ObsStatus!
  activeStatus: ObsActiveStatus!
  visualizationTime: Timestamp
  posAngleConstraint: PosAngleConstraint!
  plannedTime: PlannedTimeSummary! @deprecated(reason: "the PlannedTimeSummary type will be replaced")
  program: Program!
  targetEnvironment: TargetEnvironment!
  constraintSet: ConstraintSet!
  timingWindows: [TimingWindow!]!
  obsAttachments: [ObsAttachment!]!
  scienceRequirements: ScienceRequirements!
  observingMode: ObservingMode

  """
  The instrument in use for this observation, if the observing mode is set.
  """
  instrument: Instrument
  execution: Execution!

  """
  The ITC result for this observation, assuming it has associated target(s)
  and a selected observing mode.
  """
  itc(
    """
    Whether to use cached results (true) or ignore the cache and make a remote ITC call (false).
    """
    useCache: Boolean = true
  ): ItcResultSet

  """
  Produces the execution configuration with its acquisition and science
  sequences for this observation.
  """
  sequence(
    """
    Whether to use cached results (true) or ignore the cache and make a remote ITC call (false).
    """
    useCache: Boolean = true

    """
    The maximum size (number of atoms) of the `possibleFuture` in the sequences.
    If the projected future is longer, the size will be capped at this value.
    Use 0 if only interested in the `nextAtom`.  The maximum is 100.  Each
    sequence has `hasMore` and `atomCount` fields that can be used to determine
    whether and how many remaining atoms are yet to be executed.
    """
    futureLimit: PosInt = 25
  ): SequenceGenerationResult
}

scalar ObservationId

type ObservationSelectResult {
  matches: [Observation!]!
  hasMore: Boolean!
}

enum ObserveClass {
  SCIENCE
  PROGRAM_CAL
  PARTNER_CAL
  ACQUISITION
  ACQUISITION_CAL
  DAY_CAL
}

type Parallax {
  microarcseconds: Long!
  milliarcseconds: BigDecimal!
}

type PartnerSplit {
  partner: Partner!
  percent: IntPercent!
}

enum PlanetSpectrum {
  MARS
  JUPITER
  SATURN
  URANUS
  NEPTUNE
}

enum PlanetaryNebulaSpectrum {
  NGC7009
  IC5117
}

type PlannedTime {
  charges: [PlannedTimeCharge!]!
  total: TimeSpan!
}

type PlannedTimeCharge {
  chargeClass: ChargeClass!
  time: TimeSpan!
}

type PlannedTimeSummary {
  pi: TimeSpan! @deprecated(reason: "the PlannedTimeSummary type will be removed")
  uncharged: TimeSpan! @deprecated(reason: "the PlannedTimeSummary type will be removed")
  execution: TimeSpan! @deprecated(reason: "the PlannedTimeSummary type will be removed")
}

type PoorWeather implements ProposalClass {
  minPercentTime: IntPercent!
}

type PosAngleConstraint {
  mode: PosAngleConstraintMode!
  angle: Angle!
}

enum PosAngleConstraintMode {
  UNBOUNDED
  FIXED
  ALLOW_FLIP
  AVERAGE_PARALLACTIC
  PARALLACTIC_OVERRIDE
}

scalar PosBigDecimal

scalar PosInt

type Program {
  id: ProgramId!
  existence: Existence!
  name: NonEmptyString
  proposal: Proposal

  """Principal Investigator"""
  pi: User

  """Users assigned to this science program"""
  users: [ProgramUser!]!
  observations(includeDeleted: Boolean! = false, OFFSET: ObservationId, LIMIT: NonNegInt): ObservationSelectResult!
  obsAttachments: [ObsAttachment!]!
  proposalAttachments: [ProposalAttachment!]!
  plannedTime: PlannedTimeSummary! @deprecated(reason: "the PlannedTimeSummary type will be replaced")

  """Top-level group elements (observations and sub-groups) in the program."""
  groupElements: [GroupElement!]!

  """All group elements (observations and sub-groups) in the program."""
  allGroupElements: [GroupElement!]!
}

scalar ProgramId

type ProgramSelectResult {
  matches: [Program!]!
  hasMore: Boolean!
}

type ProperMotion {
  ra: ProperMotionRA!
  dec: ProperMotionDeclination!
}

type ProperMotionDeclination {
  microarcsecondsPerYear: Long!
  milliarcsecondsPerYear: BigDecimal!
}

type ProperMotionRA {
  microarcsecondsPerYear: Long!
  milliarcsecondsPerYear: BigDecimal!
}

type ProposalAttachment {
  attachmentType: ProposalAttachmentType!
  fileName: NonEmptyString!
  description: NonEmptyString
  checked: Boolean!
  fileSize: Long!
  updatedAt: Timestamp!
  program: Program!
}

input ProposalAttachmentPropertiesInput {
  description: NonEmptyString
  checked: Boolean
}

type ProposalAttachmentTypeMeta {
  tag: ProposalAttachmentType!
  shortName: String!
  longName: String!
}

type Proposal {
  title: NonEmptyString
  proposalClass: ProposalClass!
  category: TacCategory
  toOActivation: ToOActivation
  abstract: NonEmptyString
  partnerSplits: [PartnerSplit!]!
}

interface ProposalClass {
  minPercentTime: IntPercent!
}

enum ProposalClassEnum {
  CLASSICAL
  DEMO_SCIENCE
  DIRECTORS_TIME
  EXCHANGE
  FAST_TURNAROUND
  INTENSIVE
  LARGE_PROGRAM
  POOR_WEATHER
  QUEUE
  SYSTEM_VERIFICATION
}

enum QuasarSpectrum {
  QS0
  QS02
}

type Query {
  asterismGroup(programId: ProgramId!, WHERE: WhereObservation, LIMIT: NonNegInt, includeDeleted: Boolean! = false): AsterismGroupSelectResult!
  obsAttachmentTypeMeta: [ObsAttachmentTypeMeta!]!
  constraintSetGroup(programId: ProgramId!, WHERE: WhereObservation, LIMIT: NonNegInt, includeDeleted: Boolean! = false): ConstraintSetGroupSelectResult!
  dataset(observationId: ObservationId!, stepId: StepId!, index: PosInt!): Dataset
  datasets(WHERE: WhereDataset, OFFSET: DatasetIdInput, LIMIT: NonNegInt): DatasetSelectResult!
  executionEvents(WHERE: WhereExecutionEvent, OFFSET: ExecutionEventId, LIMIT: NonNegInt): ExecutionEventSelectResult!
  filterTypeMeta: [FilterTypeMeta!]!

  """
  ITC execution results.  DEPRECATED (use the `observation` query and select the
  `itc` field instead).
  """
  itc(
    programId: ProgramId!
    observationId: ObservationId!

    """
    Whether to use cached results (true) or ignore the cache and make a remote ITC call (false).
    """
    useCache: Boolean! = true
  ): ItcResultSet @deprecated(reason: "use observation(observationId: \"o-111\") { itc {...} } instead")
  observation(observationId: ObservationId!): Observation
  observations(programId: ProgramId, WHERE: WhereObservation, OFFSET: ObservationId, LIMIT: NonNegInt, includeDeleted: Boolean! = false): ObservationSelectResult!
  partnerMeta: [PartnerMeta!]!
  program(programId: ProgramId!): Program
  programs(WHERE: WhereProgram, OFFSET: ProgramId, LIMIT: NonNegInt, includeDeleted: Boolean! = false): ProgramSelectResult!
  proposalAttachmentTypeMeta: [ProposalAttachmentTypeMeta!]!

  """
  Produces the execution configuration with its acquisition and science
  sequences for this observation.  DEPRECATED (use the `observation` query and
  select the `sequence` field instead.
  """
  sequence(
    programId: ProgramId!
    observationId: ObservationId!

    """
    Whether to use cached results (true) or ignore the cache and make a remote ITC call (false).
    """
    useCache: Boolean! = true

    """
    The maximum size (number of atoms) of the 'possibleFuture' in the sequences.
    If the projected future is longer, the size will be capped at this value.
    Use 0 if only interested in the 'nextAtom'.  The maximum is 100.  Each
    sequence has 'hasMore' and 'atomCount' fields that can be used to determine
    whether and how many remaining atoms are yet to be executed.
    """
    futureLimit: PosInt! = 25
  ): SequenceGenerationResult @deprecated(reason: "use observation(observationId: \"o-111\") { sequence {...} } instead")
  target(targetId: TargetId!): Target
  targetGroup(programId: ProgramId!, WHERE: WhereObservation, LIMIT: NonNegInt, includeDeleted: Boolean! = false): TargetGroupSelectResult!
  targets(WHERE: WhereTarget, OFFSET: TargetId, LIMIT: NonNegInt, includeDeleted: Boolean! = false): TargetSelectResult!
}

type Queue implements ProposalClass {
  minPercentTime: IntPercent!
}

type RadialVelocity {
  centimetersPerSecond: Long!
  metersPerSecond: BigDecimal!
  kilometersPerSecond: BigDecimal!
}

type RightAscension {
  hms: HmsString!
  hours: BigDecimal!
  degrees: BigDecimal!
  microarcseconds: Long! @deprecated
  microseconds: Long!
}

type ObservingMode {
  instrument: Instrument!
  mode: ObservingModeType!
  gmosNorthLongSlit: GmosNorthLongSlit
  gmosSouthLongSlit: GmosSouthLongSlit
}

type ObservingModeGroup {
  observationIds: [ObservationId!]!
  observations(includeDeleted: Boolean! = false, OFFSET: ObservationId, LIMIT: NonNegInt): ObservationSelectResult!
  observingMode: ObservingMode
}

type ObservingModeGroupSelectResult {
  matches: [ObservingModeGroup!]!
  hasMore: Boolean!
}

enum ScienceMode {
  IMAGING
  SPECTROSCOPY
}

type ScienceRequirements {
  mode: ScienceMode!
  spectroscopy: SpectroscopyScienceRequirements!
}

type ScienceRequirementsGroup {
  observationIds: [ObservationId!]!
  observations(includeDeleted: Boolean! = false, OFFSET: ObservationId, LIMIT: NonNegInt): ObservationSelectResult!
  scienceRequirements: ScienceRequirements!
}

type ScienceRequirementsGroupSelectResult {
  matches: [ScienceRequirementsGroup!]!
  hasMore: Boolean!
}

"""Sequence-level command"""
enum SequenceCommand {
  """SequenceCommand ABORT"""
  ABORT

  """SequenceCommand CONTINUE"""
  CONTINUE

  """SequenceCommand PAUSE"""
  PAUSE

  """SequenceCommand START"""
  START

  """SequenceCommand STOP"""
  STOP
}

type SequenceDigest {
  observeClass: ObserveClass!
  plannedTime: PlannedTime!
  offsets: [Offset!]!
}

type SequenceEvent {
  id: ExecutionEventId!
  visitId: VisitId!
  command: SequenceCommand!
  observation: Observation!
  received: Timestamp!
}

type SequenceGenerationResult {
  programId: ProgramId!
  observationId: ObservationId!
  itcResult: ItcResultSet!
  executionConfig: ExecutionConfig!
  scienceDigest: SequenceDigest
}

enum SequenceType {
  ACQUISITION
  SCIENCE
}

type Sidereal {
  ra: RightAscension!
  dec: Declination!
  epoch: EpochString!
  properMotion: ProperMotion
  radialVelocity: RadialVelocity
  parallax: Parallax
  catalogInfo: CatalogInfo
}

scalar SignalToNoise

type SignalToNoiseMode {
  value: SignalToNoise!
}

enum SkyBackground {
  DARKEST
  DARK
  GRAY
  BRIGHT
}

type SourceProfile {
  point: SpectralDefinitionIntegrated
  uniform: SpectralDefinitionSurface
  gaussian: GaussianSource
}

type SpectralDefinitionIntegrated {
  bandNormalized: BandNormalizedIntegrated
  emissionLines: EmissionLinesIntegrated
}

type SpectralDefinitionSurface {
  bandNormalized: BandNormalizedSurface
  emissionLines: EmissionLinesSurface
}

enum SpectroscopyCapabilities {
  NOD_AND_SHUFFLE
  POLARIMETRY
  CORONAGRAPHY
}

type SpectroscopyScienceRequirements {
  wavelength: Wavelength
  resolution: PosInt
  signalToNoise: SignalToNoise
  signalToNoiseAt: Wavelength
  wavelengthCoverage: Wavelength
  focalPlane: FocalPlane
  focalPlaneAngle: Angle
  capability: SpectroscopyCapabilities
}

enum StellarLibrarySpectrum {
  O5_V
  O8_III
  B0_V
  B5_7_V
  B5_III
  B5_I
  A0_V
  A0_III
  A0_I
  A5_V
  A5_III
  F0_V
  F0_III
  F0_I
  F5_V
  F5_V_W
  F6_V_R
  F5_III
  F5_I
  G0_V
  G0_V_W
  G0_V_R
  G0_III
  G0_I
  G2_V
  G5_V
  G5_V_W
  G5_V_R
  G5_III
  G5_III_W
  G5_III_R
  G5_I
  K0_V
  K0_V_R
  K0_III
  K0_III_W
  K0_III_R
  K0_1_II
  K4_V
  K4_III
  K4_III_W
  K4_III_R
  K4_I
  M0_V
  M0_III
  M3_V
  M3_III
  M6_V
  M6_III
  M9_III
}

"""
Step-level events.  The execution of a single step will generate multiple events.
"""
type StepEvent {
  """Event id"""
  id: ExecutionEventId!

  """Identifies the step to which the event refers."""
  stepId: StepId!

  """Associated visit."""
  visitId: VisitId!

  """Whether this is an acquisition or science sequence step."""
  sequenceType: SequenceType!

  """Step execution stage."""
  stepStage: StepStage!

  """Observation whose execution produced this event."""
  observation: Observation!

  """Time at which this event was received"""
  received: Timestamp!
}

"""
StepId id formatted as `s-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}`
"""
scalar StepId

"""Execution stage or phase of an individual step"""
enum StepStage {
  END_CONFIGURE
  END_OBSERVE
  END_STEP
  START_CONFIGURE
  START_OBSERVE
  START_STEP
}

type ConfigChangeEstimate {
  name: String!
  description: String!
  estimate: TimeSpan!
}

type AllConfigChangeEstimates {
  selected: ConfigChangeEstimate!
  index: NonNegInt!
  all: [ConfigChangeEstimate!]!
  estimate: TimeSpan!
}

type DatasetEstimate {
  exposure: TimeSpan!
  readout: TimeSpan!
  write: TimeSpan!
  estimate: TimeSpan!
}

type DetectorEstimate {
  name: String!
  description: String!
  dataset: DatasetEstimate!
  count: NonNegInt!
  estimate: TimeSpan!
}

type AllDetectorEstimates {
  selected: DetectorEstimate!
  index: NonNegInt!
  all: [DetectorEstimate!]!
  estimate: TimeSpan!
}

type StepEstimate {
  configChange: AllConfigChangeEstimates
  detector: AllDetectorEstimates
  total: TimeSpan!
}

type SystemVerification implements ProposalClass {
  minPercentTime: IntPercent!
}

enum TacCategory {
  SMALL_BODIES
  PLANETARY_ATMOSPHERES
  PLANETARY_SURFACES
  SOLAR_SYSTEM_OTHER
  EXOPLANET_RADIAL_VELOCITIES
  EXOPLANET_ATMOSPHERES_ACTIVITY
  EXOPLANET_TRANSITS
  EXOPLANET_HOST_STAR
  EXOPLANET_OTHER
  STELLAR_ASTROPHYSICS
  STELLAR_POPULATIONS
  STAR_FORMATION
  GASEOUS_ASTROPHYSICS
  STELLAR_REMNANTS
  GALACTIC_OTHER
  COSMOLOGY
  CLUSTERS_OF_GALAXIES
  HIGH_Z_UNIVERSE
  LOW_Z_UNIVERSE
  ACTIVE_GALAXIES
  EXTRAGALACTIC_OTHER
}

type Target {
  id: TargetId!
  existence: Existence!
  program(includeDeleted: Boolean! = false): Program!
  name: NonEmptyString!
  sourceProfile: SourceProfile!
  sidereal: Sidereal
  nonsidereal: Nonsidereal
}

type TargetEnvironment {
  asterism(includeDeleted: Boolean! = false): [Target!]!
  firstScienceTarget(includeDeleted: Boolean! = false): Target
  explicitBase: Coordinates
}

type TargetEnvironmentGroup {
  observationIds: [ObservationId!]!
  observations(includeDeleted: Boolean! = false, OFFSET: ObservationId, LIMIT: NonNegInt): ObservationSelectResult!
  targetEnvironment: TargetEnvironment!
}

type TargetEnvironmentGroupSelectResult {
  matches: [TargetEnvironmentGroup!]!
  hasMore: Boolean!
}

type TargetGroup {
  observations(includeDeleted: Boolean! = false, OFFSET: ObservationId, LIMIT: NonNegInt): ObservationSelectResult!
  target: Target!
  program: Program! @deprecated
}

type TargetGroupSelectResult {
  matches: [TargetGroup!]!
  hasMore: Boolean!
}

scalar TargetId

type TargetSelectResult {
  matches: [Target!]!
  hasMore: Boolean!
}

enum ToOActivation {
  NONE
  STANDARD
  RAPID
}

input UnlinkUserInput {
  """The program to unlink the user from."""
  programId: ProgramId!

  """The user to unlink."""
  userId: UserId!
}

type UnlinkUserResult {
  """Returns true if the user was unlinked, false if no such link existed."""
  result: Boolean!
}

type UnnormalizedSed {
  stellarLibrary: StellarLibrarySpectrum
  coolStar: CoolStarTemperature
  galaxy: GalaxySpectrum
  planet: PlanetSpectrum
  quasar: QuasarSpectrum
  hiiRegion: HiiRegionSpectrum
  planetaryNebula: PlanetaryNebulaSpectrum
  powerLaw: BigDecimal
  blackBodyTempK: PosInt
  fluxDensities: [FluxDensityEntry!]
}

scalar UserId

enum UserType {
  GUEST
  STANDARD
  SERVICE
}

type User {
  id: UserId!
  type: UserType!
  serviceName: String
  orcidId: String
  orcidGivenName: String
  orcidCreditName: String
  orcidFamilyName: String
  orcidEmail: String
}

"""VisitId id formatted as `v-[1-9a-f][0-9a-f]*`"""
scalar VisitId

enum WaterVapor {
  VERY_DRY
  DRY
  MEDIAN
  WET
}

type Wavelength {
  picometers: PosInt!
  angstroms: PosBigDecimal!
  nanometers: PosBigDecimal!
  micrometers: PosBigDecimal!
}

type WavelengthDither {
  picometers: Int!
  angstroms: BigDecimal!
  nanometers: BigDecimal!
  micrometers: BigDecimal!
}

input WhereObsAttachment {
  AND: [WhereObsAttachment!]
  OR: [WhereObsAttachment!]
  NOT: WhereObsAttachment
  id: WhereOrderObsAttachmentId
  fileName: WhereString
  description: WhereOptionString
  attachmentType: WhereObsAttachmentType
  checked: Boolean
}

input WhereObsAttachmentType {
  EQ: ObsAttachmentType
  NEQ: ObsAttachmentType
  IN: [ObsAttachmentType!]
  NIN: [ObsAttachmentType!]
}

input WhereOrderObsAttachmentId {
  EQ: ObsAttachmentId
  NEQ: ObsAttachmentId
  IN: [ObsAttachmentId!]
  NIN: [ObsAttachmentId!]
  GT: ObsAttachmentId
  LT: ObsAttachmentId
  GTE: ObsAttachmentId
  LTE: ObsAttachmentId
}

input WhereDataset {
  observationId: WhereOrderObservationId
  stepId: WhereEqStepId
  index: WhereOrderDatasetIndex
  filename: WhereString
  qaState: WhereOptionEqQaState
}

input WhereDatasetEvent {
  stepId: WhereEqStepId
  index: WhereOrderDatasetIndex
  stage: WhereOrderDatasetStage
  filename: WhereOptionString
}

input WhereEqPartner {
  EQ: Partner
  NEQ: Partner
  IN: [Partner!]
  NIN: [Partner!]
}

input WhereEqProposalClassType {
  EQ: ProposalClassEnum
  NEQ: ProposalClassEnum
  IN: [ProposalClassEnum!]
  NIN: [ProposalClassEnum!]
}

input WhereEqStepId {
  EQ: StepId
  NEQ: StepId
  IN: [StepId!]
  NIN: [StepId!]
}

input WhereEqToOActivation {
  EQ: ToOActivation
  NEQ: ToOActivation
  IN: [ToOActivation!]
  NIN: [ToOActivation!]
}

input WhereEqVisitId {
  EQ: VisitId
  NEQ: VisitId
  IN: [VisitId!]
  NIN: [VisitId!]
}

input WhereExecutionEvent {
  AND: [WhereExecutionEvent!]
  OR: [WhereExecutionEvent!]
  NOT: WhereExecutionEvent
  id: WhereOrderExecutionEventId
  visitId: WhereEqVisitId
  observationId: WhereOrderObservationId
  received: WhereOrderTimestamp
  sequenceEvent: WhereSequenceEvent
  stepEvent: WhereStepEvent
  datasetEvent: WhereDatasetEvent
}

input WhereObservation {
  AND: [WhereObservation!]
  OR: [WhereObservation!]
  NOT: WhereObservation
  id: WhereOrderObservationId
  subtitle: WhereOptionString
  status: WhereOrderObsStatus
  activeStatus: WhereOrderObsActiveStatus
}

input WhereGroup {
  AND: [WhereGroup!]
  OR: [WhereGroup!]
  NOT: WhereGroup
  id: WhereOrderGroupId
  name: WhereOptionString
  description: WhereOptionString
}

input WhereOrderGroupId {
  EQ: GroupId
  NEQ: GroupId
  IN: [GroupId!]
  NIN: [GroupId!]
  GT: GroupId
  LT: GroupId
  GTE: GroupId
  LTE: GroupId
}

input WhereOptionEqQaState {
  IS_NULL: Boolean
  EQ: DatasetQaState
  NEQ: DatasetQaState
  IN: [DatasetQaState!]
  NIN: [DatasetQaState!]
}

input WhereOptionEqTacCategory {
  IS_NULL: Boolean
  EQ: TacCategory
  NEQ: TacCategory
  IN: [TacCategory!]
  NIN: [TacCategory!]
}

input WhereOptionString {
  IS_NULL: Boolean
  EQ: NonEmptyString
  NEQ: NonEmptyString
  IN: [NonEmptyString!]
  NIN: [NonEmptyString!]
  LIKE: NonEmptyString
  NLIKE: NonEmptyString
  MATCH_CASE: Boolean = true
}

input WhereOrderDatasetIndex {
  EQ: PosInt
  NEQ: PosInt
  IN: [PosInt!]
  NIN: [PosInt!]
  GT: PosInt
  LT: PosInt
  GTE: PosInt
  LTE: PosInt
}

input WhereOrderDatasetStage {
  EQ: DatasetStage
  NEQ: DatasetStage
  IN: [DatasetStage!]
  NIN: [DatasetStage!]
  GT: DatasetStage
  LT: DatasetStage
  GTE: DatasetStage
  LTE: DatasetStage
}

input WhereOrderExecutionEventId {
  EQ: ExecutionEventId
  NEQ: ExecutionEventId
  IN: [ExecutionEventId!]
  NIN: [ExecutionEventId!]
  GT: ExecutionEventId
  LT: ExecutionEventId
  GTE: ExecutionEventId
  LTE: ExecutionEventId
}

input WhereOrderTimestamp {
  EQ: Timestamp
  NEQ: Timestamp
  IN: [Timestamp!]
  NIN: [Timestamp!]
  GT: Timestamp
  LT: Timestamp
  GTE: Timestamp
  LTE: Timestamp
}

input WhereOrderInt {
  EQ: Int
  NEQ: Int
  IN: [Int!]
  NIN: [Int!]
  GT: Int
  LT: Int
  GTE: Int
  LTE: Int
}

input WhereOrderObsActiveStatus {
  EQ: ObsActiveStatus
  NEQ: ObsActiveStatus
  IN: [ObsActiveStatus!]
  NIN: [ObsActiveStatus!]
  GT: ObsActiveStatus
  LT: ObsActiveStatus
  GTE: ObsActiveStatus
  LTE: ObsActiveStatus
}

input WhereOrderObsStatus {
  EQ: ObsStatus
  NEQ: ObsStatus
  IN: [ObsStatus!]
  NIN: [ObsStatus!]
  GT: ObsStatus
  LT: ObsStatus
  GTE: ObsStatus
  LTE: ObsStatus
}

input WhereOrderObservationId {
  EQ: ObservationId
  NEQ: ObservationId
  IN: [ObservationId!]
  NIN: [ObservationId!]
  GT: ObservationId
  LT: ObservationId
  GTE: ObservationId
  LTE: ObservationId
}

input WhereOrderProgramId {
  EQ: ProgramId
  NEQ: ProgramId
  IN: [ProgramId!]
  NIN: [ProgramId!]
  GT: ProgramId
  LT: ProgramId
  GTE: ProgramId
  LTE: ProgramId
}

input WhereOrderSequenceCommand {
  EQ: SequenceCommand
  NEQ: SequenceCommand
  IN: [SequenceCommand!]
  NIN: [SequenceCommand!]
  GT: SequenceCommand
  LT: SequenceCommand
  GTE: SequenceCommand
  LTE: SequenceCommand
}

input WhereOrderSequenceType {
  EQ: SequenceType
  NEQ: SequenceType
  IN: [SequenceType!]
  NIN: [SequenceType!]
  GT: SequenceType
  LT: SequenceType
  GTE: SequenceType
  LTE: SequenceType
}

input WhereOrderStepStage {
  EQ: StepStage
  NEQ: StepStage
  IN: [StepStage!]
  NIN: [StepStage!]
  GT: StepStage
  LT: StepStage
  GTE: StepStage
  LTE: StepStage
}

input WhereOrderTargetId {
  EQ: TargetId
  NEQ: TargetId
  IN: [TargetId!]
  NIN: [TargetId!]
  GT: TargetId
  LT: TargetId
  GTE: TargetId
  LTE: TargetId
}

input WhereProgram {
  AND: [WhereProgram!]
  OR: [WhereProgram!]
  NOT: WhereProgram
  id: WhereOrderProgramId
  name: WhereOptionString
  proposal: WhereProposal
}

input WhereProposal {
  IS_NULL: Boolean
  AND: [WhereProposal!]
  OR: [WhereProposal!]
  NOT: WhereProposal
  title: WhereOptionString
  class: WhereProposalClass
  category: WhereOptionEqTacCategory
  toOActivation: WhereEqToOActivation
  abstract: WhereOptionString
  partners: WhereProposalPartners
}

input WhereProposalAttachment {
  AND: [WhereProposalAttachment!]
  OR: [WhereProposalAttachment!]
  NOT: WhereProposalAttachment
  fileName: WhereString
  description: WhereOptionString
  attachmentType: WhereProposalAttachmentType
  checked: Boolean
}

input WhereProposalAttachmentType {
  EQ: ProposalAttachmentType
  NEQ: ProposalAttachmentType
  IN: [ProposalAttachmentType!]
  NIN: [ProposalAttachmentType!]
}

input WhereProposalClass {
  type: WhereEqProposalClassType
  minPercent: WhereOrderInt
}

input WhereProposalPartnerEntry {
  AND: [WhereProposalPartnerEntry!]
  OR: [WhereProposalPartnerEntry!]
  NOT: WhereProposalPartnerEntry
  partner: WhereEqPartner
  percent: WhereOrderInt
}

input WhereProposalPartners {
  MATCH: WhereProposalPartnerEntry
  EQ: [Partner!]
  isJoint: Boolean
}

input WhereSequenceEvent {
  command: WhereOrderSequenceCommand
}

input WhereStepEvent {
  stepId: WhereEqStepId
  sequenceType: WhereOrderSequenceType
  stage: WhereOrderStepStage
}

input WhereString {
  EQ: NonEmptyString
  NEQ: NonEmptyString
  IN: [NonEmptyString!]
  NIN: [NonEmptyString!]
  LIKE: NonEmptyString
  NLIKE: NonEmptyString
  MATCH_CASE: Boolean = true
}

input WhereTarget {
  AND: [WhereTarget!]
  OR: [WhereTarget!]
  NOT: WhereTarget
  id: WhereOrderTargetId
  programId: WhereOrderProgramId
  name: WhereString
}

type OffsetQ {
  microarcseconds: Long!
  milliarcseconds: BigDecimal!
  arcseconds: BigDecimal!
}

scalar BigDecimal

scalar Long

"""Enumerated type of observation attachments."""
enum ObsAttachmentType {
  """Finder Chart"""
  FINDER

  """MOS Mask"""
  MOS_MASK

  """Pre-Imaging"""
  PRE_IMAGING
}

"""Enumerated type of proposal attachments."""
enum ProposalAttachmentType {
  """Science Case & Design"""
  SCIENCE

  """Team Info, Previous Use, etc."""
  TEAM
}

"""Enumerated type of filters."""
enum FilterType {
  """Broad-Band Filter"""
  BroadBand

  """Combination Filter"""
  Combination

  """Engineering Filter"""
  Engineering

  """Narrow-Band Filter"""
  NarrowBand

  """Spectroscopic Filter"""
  Spectroscopic
}

"""Enumerated type of partners."""
enum Partner {
  """Argentina"""
  AR

  """Brazil"""
  BR

  """Canada"""
  CA

  """Canada-France-Hawaii Telescope"""
  CFH

  """Chile"""
  CL

  """Guaranteed Time"""
  GT

  """Keck Observatory"""
  KECK

  """Republic of Korea"""
  KR

  """Long Programs"""
  LP

  """Subaru Telescope"""
  SUBARU

  """University of Hawaii"""
  UH

  """United States"""
  US
}

"""Enumerated type of expected conditions."""
enum ConditionsExpectationType {
  """Clear Skies"""
  CLEAR_SKIES

  """Fog"""
  FOG

  """Thick Clouds"""
  THICK_CLOUDS

  """Thin Clouds"""
  THIN_CLOUDS
}

"""Enumerated type of sources for observed conditions."""
enum ConditionsMeasurementSource {
  """Observer"""
  OBSERVER
}

"""Enumerated type of seeing trends."""
enum SeeingTrend {
  """Getting Better"""
  GETTING_BETTER

  """Getting Worse"""
  GETTING_WORSE

  """Staying the Same"""
  STAYING_THE_SAME

  """Variable"""
  VARIABLE
}

