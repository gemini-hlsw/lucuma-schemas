# DatasetEvent creation parameters
input AddDatasetEventInput {
  visitId: VisitId!
  location: DatasetEventLocationInput!
  payload: DatasetEventPayloadInput!
}

# SequenceEvent creation parameters
input AddSequenceEventInput {
  visitId: VisitId!
  location: SequenceEventLocationInput!
  payload: SequenceEventPayloadInput!
}

# StepEvent creation parameters
input AddStepEventInput {
  visitId: VisitId!
  location: StepEventLocationInput!
  payload: StepEventPayloadInput!
}

type AirMassRange {
  # Minimum AirMass (unitless)
  min: BigDecimal!

  # Maximum AirMass (unitless)
  max: BigDecimal!
}

# Air mass range creation and edit parameters
input AirMassRangeInput {
  min: BigDecimal
  max: BigDecimal
}

type Angle {
  # Angle in µas
  microarcseconds: Long!

  # Angle in µs
  microseconds: BigDecimal!

  # Angle in mas
  milliarcseconds: BigDecimal!

  # Angle in ms
  milliseconds: BigDecimal!

  # Angle in asec
  arcseconds: BigDecimal!

  # Angle in sec
  seconds: BigDecimal!

  # Angle in amin
  arcminutes: BigDecimal!

  # Angle in min
  minutes: BigDecimal!

  # Angle in deg
  degrees: BigDecimal!

  # Angle in hrs
  hours: BigDecimal!
}

# Create an angle from a signed value.  Choose exactly one of the available units.
input AngleInput {
  microarcseconds: Long
  microseconds: BigDecimal
  milliarcseconds: BigDecimal
  milliseconds: BigDecimal
  arcseconds: BigDecimal
  seconds: BigDecimal
  arcminutes: BigDecimal
  minutes: BigDecimal
  degrees: BigDecimal
  hours: BigDecimal
  dms: String
  hms: String
  fromLong: LongAngleInput
  fromDecimal: DecimalAngleInput
}

# Angle units
enum AngleUnits {
  # AngleUnits Microarcseconds
  MICROARCSECONDS

  # AngleUnits Microseconds
  MICROSECONDS

  # AngleUnits Milliarcseconds
  MILLIARCSECONDS

  # AngleUnits Milliseconds
  MILLISECONDS

  # AngleUnits Arcseconds
  ARCSECONDS

  # AngleUnits Seconds
  SECONDS

  # AngleUnits Arcminutes
  ARCMINUTES

  # AngleUnits Minutes
  MINUTES

  # AngleUnits Degrees
  DEGREES

  # AngleUnits Hours
  HOURS
}

type AsterismGroup {
  # IDs of observations that use the same constraints
  observationIds: [ObservationId!]!

  # Observations that use this constraint set
  observations(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ObservationConnection!

  # Commonly held value across the observations
  asterism: [Target!]!
}

# Observations grouped by common properties
type AsterismGroupConnection {
  # The nodes in all the edges from the current page
  nodes: [AsterismGroup!]!

  # Edges in the current page
  edges: [AsterismGroupEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# An observation group and its cursor
type AsterismGroupEdge {
  # AsterismGroupEdge element
  node: AsterismGroup!

  # AsterismGroupEdge element cursor
  cursor: Cursor!
}

# Sequence atom
interface Atom {
  # Atom id
  id: AtomId!
}

# AtomId id formatted as `a-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}`
scalar AtomId

# Brightness bands
enum Band {
  # Band SloanU
  SLOAN_U

  # Band SloanG
  SLOAN_G

  # Band SloanR
  SLOAN_R

  # Band SloanI
  SLOAN_I

  # Band SloanZ
  SLOAN_Z

  # Band U
  U

  # Band B
  B

  # Band V
  V

  # Band R
  R

  # Band I
  I

  # Band Y
  Y

  # Band J
  J

  # Band H
  H

  # Band K
  K

  # Band L
  L

  # Band M
  M

  # Band N
  N

  # Band Q
  Q

  # Band Ap
  AP

  # Band Gaia
  GAIA

  # Band GaiaBP
  GAIA_BP

  # Band GaiaRP
  GAIA_RP
}

type BandBrightnessIntegrated {
  # Magnitude band
  band: Band!
  value: BigDecimal!
  units: BrightnessIntegratedUnits!

  # Error, if any
  error: BigDecimal
}

# Create or edit a band brightness value with integrated magnitude units.  When
# creating a new value, all fields except "error" are required.
input BandBrightnessIntegratedInput {
  band: Band!

  # The value field is required when creating a new instance of BandBrightnessIntegrated, but optional when editing
  value: BigDecimal

  # The units field is required when creating a new instance of BandBrightnessIntegrated, but optional when editing
  units: BrightnessIntegratedUnits

  # Error values are optional
  error: BigDecimal
}

type BandBrightnessSurface {
  # Magnitude band
  band: Band!
  value: BigDecimal!
  units: BrightnessSurfaceUnits!

  # Error, if any
  error: BigDecimal
}

# Create or edit a band brightness value with surface magnitude units.  When
# creating a new value, all fields except "error" are required.
input BandBrightnessSurfaceInput {
  band: Band!

  # The value field is required when creating a new instance of BandBrightnessSurface, but optional when editing
  value: BigDecimal

  # The units field is required when creating a new instance of BandBrightnessSurface, but optional when editing
  units: BrightnessSurfaceUnits

  # Error values are optional
  error: BigDecimal
}

# Band normalized common interface
interface BandNormalized {
  # Un-normalized spectral energy distribution
  sed: UnnormalizedSed!
}

type BandNormalizedIntegrated implements BandNormalized {
  brightnesses: [BandBrightnessIntegrated!]!

  # Un-normalized spectral energy distribution
  sed: UnnormalizedSed!
}

# Create or edit a band normalized value with integrated magnitude units.  Specify
# both "sed" and "brightnesses" when creating a new BandNormalizedIntegrated.
input BandNormalizedIntegratedInput {
  # The sed field is required when creating a new instance of BandNormalizedIntegrated, but optional when editing
  sed: UnnormalizedSedInput

  # The brightnesses field is required when creating a new instance of BandNormalizedIntegrated, but optional when editing
  brightnesses: [BandBrightnessIntegratedInput!]

  # Optional field that may be provided to edit existing brightness definitions or add new ones
  editBrightnesses: [BandBrightnessIntegratedInput!]

  # Optional field that may be provided to delete existing brightness definitions identified by band
  deleteBrightnesses: [Band!]
}

type BandNormalizedSurface implements BandNormalized {
  brightnesses: [BandBrightnessSurface!]!

  # Un-normalized spectral energy distribution
  sed: UnnormalizedSed!
}

# Create or edit a band normalized value with surface magnitude units.  Specify
# both "sed" and "brightnesses" when creating a new BandNormalizedSurface.
input BandNormalizedSurfaceInput {
  # The sed field is required when creating a new instance of BandNormalizedSurface, but optional when editing
  sed: UnnormalizedSedInput

  # The brightnesses field is required when creating a new instance of BandNormalizedSurface, but optional when editing
  brightnesses: [BandBrightnessSurfaceInput!]

  # Optional field that may be provided to edit existing brightness definitions or add new ones
  editBrightnesses: [BandBrightnessSurfaceInput!]

  # Optional field that may be provided to delete existing brightness definitions identified by band
  deleteBrightnesses: [Band!]
}

# Bias calibration step
type Bias implements StepConfig {
  # Step type
  stepType: StepType!
}

# The `BigDecimal` scalar type represents signed fractional values with arbitrary precision.
scalar BigDecimal

# Stopping point in a series of steps
enum Breakpoint {
  # Breakpoint Enabled
  ENABLED

  # Breakpoint Disabled
  DISABLED
}

# Brightness integrated units
enum BrightnessIntegratedUnits {
  # Vega mag
  VEGA_MAGNITUDE

  # AB mag
  AB_MAGNITUDE

  # Jy
  JANSKY

  # W/m²/µm
  W_PER_M_SQUARED_PER_UM

  # erg/s/cm²/Å
  ERG_PER_S_PER_CM_SQUARED_PER_A

  # erg/s/cm²/Hz
  ERG_PER_S_PER_CM_SQUARED_PER_HZ
}

# Brightness surface units
enum BrightnessSurfaceUnits {
  # Vega mag/arcsec²
  VEGA_MAG_PER_ARCSEC_SQUARED

  # AB mag/arcsec²
  AB_MAG_PER_ARCSEC_SQUARED

  # Jy/arcsec²
  JY_PER_ARCSEC_SQUARED

  # W/m²/µm/arcsec²
  W_PER_M_SQUARED_PER_UM_PER_ARCSEC_SQUARED

  # erg/s/cm²/Å/arcsec²
  ERG_PER_S_PER_CM_SQUARED_PER_A_PER_ARCSEC_SQUARED

  # erg/s/cm²/Hz/arcsec²
  ERG_PER_S_PER_CM_SQUARED_PER_HZ_PER_ARCSEC_SQUARED
}

# Input for bulk editing multiple observations.  Select observations
# with the 'select' input and specify the changes in 'edit'.
#
input BulkEditAsterismInput {
  select: BulkEditSelectInput!
  edit: [EditAsterismInput!]!
}

# Input for bulk editing multiple observations.  Select observations
# with the 'select' input and specify the changes in 'edit'.
#
input BulkEditConstraintSetInput {
  select: BulkEditSelectInput!
  edit: ConstraintSetInput!
}

# Input for bulk editing multiple observations.  Select observations
# with the 'select' input and specify the changes in 'edit'.
#
input BulkEditScienceModeInput {
  select: BulkEditSelectInput!
  edit: ScienceModeInput!
}

# Input for bulk editing multiple observations.  Select observations
# with the 'select' input and specify the changes in 'edit'.
#
input BulkEditScienceRequirementsInput {
  select: BulkEditSelectInput!
  edit: ScienceRequirementsInput!
}

# Observation selection.  Choose 'programId' to select all of a program's
# observations or else list individual observations in 'observationIds'.
#       
input BulkEditSelectInput {
  programId: ProgramId
  observationIds: [ObservationId!]
}

# Input for bulk editing multiple observations.  Select observations
# with the 'select' input and specify the changes in 'edit'.
#
input BulkEditTargetEnvironmentInput {
  select: BulkEditSelectInput!
  edit: TargetEnvironmentInput!
}

type CatalogInfo {
  # Catalog name option
  name: CatalogName!

  # Catalog id string
  id: String!

  # Catalog description of object morphology
  objectType: String
}

# Catalog id consisting of catalog name, string identifier and an optional object type
input CatalogInfoInput {
  # The name field must be either specified or skipped altogether.  It cannot be unset with a null value.
  name: CatalogName

  # The id field must be either specified or skipped altogether.  It cannot be unset with a null value.
  id: NonEmptyString

  # The objectType field may be unset by assigning a null value, or ignored by skipping it altogether
  objectType: NonEmptyString
}

# Catalog name values
enum CatalogName {
  # CatalogName Simbad
  SIMBAD

  # CatalogName Horizon
  HORIZON

  # CatalogName Gaia
  GAIA
}

# Parameters for cloning an existing observation.  The existingObservationId is
# required, all else is optional. Unset values will be copied from the existing
# observation, except that status will default to NEW.
input CloneObservationInput {
  existingObservationId: ObservationId!
  suggestedCloneId: ObservationId
  programId: ProgramId
  subtitle: NonEmptyString
  status: ObsStatus
  activeStatus: ObsActiveStatus
  targetEnvironment: TargetEnvironmentInput
  constraintSet: ConstraintSetInput
  scienceRequirements: ScienceRequirementsInput
  scienceMode: ScienceModeInput
}

# Cloud extinction
enum CloudExtinction {
  # CloudExtinction PointOne
  POINT_ONE

  # CloudExtinction PointThree
  POINT_THREE

  # CloudExtinction PointFive
  POINT_FIVE

  # CloudExtinction OnePointZero
  ONE_POINT_ZERO

  # CloudExtinction OnePointFive
  ONE_POINT_FIVE

  # CloudExtinction TwoPointZero
  TWO_POINT_ZERO

  # CloudExtinction ThreePointZero
  THREE_POINT_ZERO
}

# ConfigurationMode
enum ConfigurationModeType {
  # ConfigurationModeType GmosNorthLongSlit
  GMOS_NORTH_LONG_SLIT

  # ConfigurationModeType GmosSouthLongSlit
  GMOS_SOUTH_LONG_SLIT
}

type ConstraintSet {
  # Image quality
  imageQuality: ImageQuality!

  # Cloud extinction
  cloudExtinction: CloudExtinction!

  # Sky background
  skyBackground: SkyBackground!

  # Water vapor
  waterVapor: WaterVapor!

  # Either air mass range or elevation range
  elevationRange: ElevationRange!
}

type ConstraintSetGroup {
  # IDs of observations that use the same constraints
  observationIds: [ObservationId!]!

  # Observations that use this constraint set
  observations(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ObservationConnection!

  # Commonly held value across the observations
  constraintSet: ConstraintSet!
}

# Observations grouped by common properties
type ConstraintSetGroupConnection {
  # The nodes in all the edges from the current page
  nodes: [ConstraintSetGroup!]!

  # Edges in the current page
  edges: [ConstraintSetGroupEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# An observation group and its cursor
type ConstraintSetGroupEdge {
  # ConstraintSetGroupEdge element
  node: ConstraintSetGroup!

  # ConstraintSetGroupEdge element cursor
  cursor: Cursor!
}

# Constraint set creation and editing parameters
input ConstraintSetInput {
  # The imageQuality field is required when creating a new instance of ConstraintSet, but optional when editing
  imageQuality: ImageQuality

  # The cloudExtinction field is required when creating a new instance of ConstraintSet, but optional when editing
  cloudExtinction: CloudExtinction

  # The skyBackground field is required when creating a new instance of ConstraintSet, but optional when editing
  skyBackground: SkyBackground

  # The waterVapor field is required when creating a new instance of ConstraintSet, but optional when editing
  waterVapor: WaterVapor

  # The elevationRange field is required when creating a new instance of ConstraintSet, but optional when editing
  elevationRange: ElevationRangeInput
}

# Cool star temperature options
enum CoolStarTemperature {
  # 400 K
  T400_K

  # 600 K
  T600_K

  # 800 K
  T800_K

  # 900 K
  T900_K

  # 1000 K
  T1000_K

  # 1200 K
  T1200_K

  # 1400 K
  T1400_K

  # 1600 K
  T1600_K

  # 1800 K
  T1800_K

  # 2000 K
  T2000_K

  # 2200 K
  T2200_K

  # 2400 K
  T2400_K

  # 2600 K
  T2600_K

  # 2800 K
  T2800_K
}

type Coordinates {
  # Right Ascension
  ra: RightAscension!

  # Declination
  dec: Declination!
}

# Absolute coordinates relative base epoch
input CoordinatesInput {
  ra: RightAscensionInput!
  dec: DeclinationInput!
}

# Observation creation parameters
input CreateObservationInput {
  observationId: ObservationId
  programId: ProgramId!
  subtitle: NonEmptyString
  status: ObsStatus
  activeStatus: ObsActiveStatus
  targetEnvironment: TargetEnvironmentInput
  constraintSet: ConstraintSetInput
  scienceRequirements: ScienceRequirementsInput
  scienceMode: ScienceModeInput
}

# Program creation parameters
input CreateProgramInput {
  programId: ProgramId
  name: NonEmptyString
}

# Target creation parameters
input CreateTargetInput {
  targetId: TargetId
  name: NonEmptyString!
  sidereal: SiderealInput
  nonsidereal: NonsiderealInput
  sourceProfile: SourceProfileInput!
}

# Opaque object cursor
scalar Cursor

# Dark calibration step
type Dark implements StepConfig {
  # Step type
  stepType: StepType!
}

type Dataset {
  # Observation associated with this dataset
  observation: Observation!

  # Dataset id
  id: DatasetId!

  # Dataset filename
  filename: DatasetFilename!

  # Dataset QA state
  qaState: DatasetQaState
}

# Datasets in the current page
type DatasetConnection {
  # The nodes in all the edges from the current page
  nodes: [Dataset!]!

  # Edges in the current page
  edges: [DatasetEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# A Dataset and its cursor
type DatasetEdge {
  # DatasetEdge element
  node: Dataset!

  # DatasetEdge element cursor
  cursor: Cursor!
}

# Dataset-level events.  A single dataset will be associated with multiple events.
type DatasetEvent implements ExecutionEvent {
  # Identifies the associated dataset
  location: DatasetEventLocation!

  # Dataset event payload, identifying the associated filename and stage of dataset execution
  payload: DatasetEventPayload!

  # Event id
  id: ExecutionEventId!

  # Associated visit
  visitId: VisitId!

  # Observation whose execution produced this event
  observation: Observation!

  # Time at which this event was received
  received: Instant!
}

# Dataset ExecutionEvents in the current page
type DatasetEventConnection {
  # The nodes in all the edges from the current page
  nodes: [DatasetEvent!]!

  # Edges in the current page
  edges: [DatasetEventEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# A dataset ExecutionEvent and its cursor
type DatasetEventEdge {
  # DatasetEventEdge element
  node: DatasetEvent!

  # DatasetEventEdge element cursor
  cursor: Cursor!
}

# Dataset event location, pinpointing the observation, step and index of the associated dataset.
type DatasetEventLocation {
  # Observation ID
  observationId: ObservationId!

  # Step ID
  stepId: StepId!

  # Dataset index
  index: PosInt!
}

# DatasetEvent location parameters
input DatasetEventLocationInput {
  observationId: ObservationId!
  stepId: StepId!
  index: Int!
}

# Dataset event payload.
type DatasetEventPayload {
  # Dataset filename, when known
  filename: DatasetFilename

  # Dataset execution stage
  stage: DatasetStage!
}

# DatasetEvent payload parameters
input DatasetEventPayloadInput {
  stage: DatasetStage!
  filename: DatasetFilename
}

# Dataset filename in standard format in format 'N20210519S0001.fits'
scalar DatasetFilename

type DatasetId {
  # Observation ID
  observationId: ObservationId!

  # Step ID
  stepId: StepId!

  # Dataset index
  index: PosInt!
}

# Dataset QA State
enum DatasetQaState {
  # DatasetQaState Pass
  PASS

  # DatasetQaState Usable
  USABLE

  # DatasetQaState Fail
  FAIL
}

# Execution stage or phase of an individual dataset
enum DatasetStage {
  # DatasetStage END_OBSERVE
  END_OBSERVE

  # DatasetStage END_READOUT
  END_READOUT

  # DatasetStage END_WRITE
  END_WRITE

  # DatasetStage START_OBSERVE
  START_OBSERVE

  # DatasetStage START_READOUT
  START_READOUT

  # DatasetStage START_WRITE
  START_WRITE
}

# Create an angle from a signed decimal value and its units.
input DecimalAngleInput {
  value: BigDecimal!
  units: AngleUnits!
}

type Declination {
  # Declination in DD:MM:SS.SS format
  dms: DmsString!

  # Declination in signed degrees
  degrees: BigDecimal!

  # Declination in signed µas
  microarcseconds: Long!
}

# Decimal value in Declination
input DeclinationDecimalInput {
  # decimal value in associated units
  value: BigDecimal!

  # units for associated value
  units: DeclinationUnits!
}

# Declination, choose one of the available units
input DeclinationInput {
  microarcseconds: Long
  degrees: BigDecimal
  dms: DmsString
  fromLong: DeclinationLongInput
  fromDecimal: DeclinationDecimalInput
}

# Integral value in Declination
input DeclinationLongInput {
  # integral value in associated units
  value: Long!

  # units for associated value
  units: DeclinationUnits!
}

# Unit options for Declination values
enum DeclinationUnits {
  # DeclinationUnits Microarcseconds
  MICROARCSECONDS

  # DeclinationUnits Degrees
  DEGREES
}

# Target declination coordinate in format '[+/-]DD:MM:SS.sss'
scalar DmsString

# Equivalent time amount in several unit options (e.g., 120 seconds or 2 minutes)
type Duration {
  # Duration in µs
  microseconds: Long!

  # Duration in ms
  milliseconds: BigDecimal!

  # Duration in seconds
  seconds: BigDecimal!

  # Duration in minutes
  minutes: BigDecimal!

  # Duration in hours
  hours: BigDecimal!
}

# Time duration input
input DurationInput {
  # Time duration in µs
  microseconds: Long

  # Time duration in ms
  milliseconds: BigDecimal

  # Time duration in seconds
  seconds: BigDecimal

  # Time duration in minutes
  minutes: BigDecimal

  # Time duration in hours
  hours: BigDecimal
}

# Add or delete targets in an asterism
input EditAsterismInput {
  add: TargetId
  delete: TargetId
}

# Edit observation
input EditObservationInput {
  observationId: ObservationId!

  # The existence field must be either specified or skipped altogether.  It cannot be unset with a null value.
  existence: Existence

  # The subtitle field may be unset by assigning a null value, or ignored by skipping it altogether
  subtitle: NonEmptyString

  # The status field must be either specified or skipped altogether.  It cannot be unset with a null value.
  status: ObsStatus

  # The activeStatus field must be either specified or skipped altogether.  It cannot be unset with a null value.
  activeStatus: ObsActiveStatus

  # The targetEnvironment field must be either specified or skipped altogether.  It cannot be unset with a null value.
  targetEnvironment: TargetEnvironmentInput

  # The constraintSet field must be either specified or skipped altogether.  It cannot be unset with a null value.
  constraintSet: ConstraintSetInput

  # The scienceRequirements field must be either specified or skipped altogether.  It cannot be unset with a null value.
  scienceRequirements: ScienceRequirementsInput

  # The scienceMode field may be unset by assigning a null value, or ignored by skipping it altogether
  scienceMode: ScienceModeInput
}

# Edit program
input EditProgramInput {
  programId: ProgramId!

  # The existence field must be either specified or skipped altogether.  It cannot be unset with a null value.
  existence: Existence

  # The name field may be unset by assigning a null value, or ignored by skipping it altogether
  name: NonEmptyString
}

# Single target edit options
input EditTargetInput {
  targetId: TargetId!
  existence: Existence
  name: NonEmptyString
  sidereal: SiderealInput
  nonsidereal: NonsiderealInput
  sourceProfile: SourceProfileInput
}

# Type of edit that triggered an event
enum EditType {
  # EditType Created
  CREATED

  # EditType Updated
  UPDATED
}

# Either air mass range or elevation range
type ElevationRange {
  # AirMass range if elevation range is an Airmass range
  airMass: AirMassRange

  # Hour angle range if elevation range is an Hour angle range
  hourAngle: HourAngleRange
}

# Elevation range creation and edit parameters.  Choose one of airMass or hourAngle constraints.
input ElevationRangeInput {
  airMass: AirMassRangeInput
  hourAngle: HourAngleRangeInput
}

type EmissionLineIntegrated {
  wavelength: Wavelength!

  # km/s
  lineWidth: PosBigDecimal!
  lineFlux: LineFluxIntegrated!
}

# Create or edit an emission line with integrated line flux units.  When creating a new value, all fields are required.
input EmissionLineIntegratedInput {
  wavelength: WavelengthInput!

  # The lineWidth field is required when creating a new instance of EmissionLineIntegrated, but optional when editing
  lineWidth: PosBigDecimal

  # The lineFlux field is required when creating a new instance of EmissionLineIntegrated, but optional when editing
  lineFlux: LineFluxIntegratedInput
}

type EmissionLinesIntegrated {
  lines: [EmissionLineIntegrated!]!
  fluxDensityContinuum: FluxDensityContinuumIntegrated!
}

# Create or edit emission lines with integrated line flux and flux density
# continuum units. Both "lines" and "fluxDensityContinuum" are required when
# creating a new EmissionLinesIntegrated.
input EmissionLinesIntegratedInput {
  # The lines field is required when creating a new instance of EmissionLinesIntegrated, but optional when editing
  lines: [EmissionLineIntegratedInput!]

  # Optional field that may be provided to edit existing emission line definitions or add new ones
  editLines: [EmissionLineIntegratedInput!]

  # Optional field that may be provided to delete existing emission lines identified by wavelength
  deleteLines: [WavelengthInput!]

  # The fluxDensityContinuum field is required when creating a new instance of
  # EmissionLinesIntegrated, but optional when editing
  fluxDensityContinuum: FluxDensityContinuumIntegratedInput
}

type EmissionLinesSurface {
  lines: [EmissionLineSurface!]!
  fluxDensityContinuum: FluxDensityContinuumSurface!
}

# Create or edit emission lines with surface line flux and flux density continuum
# units. Both "lines" and "fluxDensityContinuum" are required when creating a new
# EmissionLinesSurface.
input EmissionLinesSurfaceInput {
  # The lines field is required when creating a new instance of EmissionLinesSurface, but optional when editing
  lines: [EmissionLineSurfaceInput!]

  # Optional field that may be provided to edit existing emission line definitions or add new ones
  editLines: [EmissionLineSurfaceInput!]

  # Optional field that may be provided to delete existing emission lines identified by wavelength
  deleteLines: [WavelengthInput!]

  # The fluxDensityContinuum field is required when creating a new instance of EmissionLinesSurface, but optional when editing
  fluxDensityContinuum: FluxDensityContinuumSurfaceInput
}

type EmissionLineSurface {
  wavelength: Wavelength!

  # km/s
  lineWidth: PosBigDecimal!
  lineFlux: LineFluxSurface!
}

# Create or edit an emission line with surface line flux units.  When creating a new value, all fields are required.
input EmissionLineSurfaceInput {
  wavelength: WavelengthInput!

  # The lineWidth field is required when creating a new instance of EmissionLineSurface, but optional when editing
  lineWidth: PosBigDecimal

  # The lineFlux field is required when creating a new instance of EmissionLineSurface, but optional when editing
  lineFlux: LineFluxSurfaceInput
}

# Ephemeris key type options
enum EphemerisKeyType {
  # EphemerisKeyType Comet
  COMET

  # EphemerisKeyType AsteroidNew
  ASTEROID_NEW

  # EphemerisKeyType AsteroidOld
  ASTEROID_OLD

  # EphemerisKeyType MajorBody
  MAJOR_BODY

  # EphemerisKeyType UserSupplied
  USER_SUPPLIED
}

# Reference observation epoch in format '[JB]YYYY.YYY'
scalar EpochString

# Common fields shared by all events
interface Event {
  id: Long!
}

type Execution {
  # Datasets associated with the observation
  datasets(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): DatasetConnection!

  # Events associated with the observation
  events(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): ExecutionEventConnection!

  # Execution config
  executionConfig: ExecutionConfig
}

# Execution configuration
interface ExecutionConfig {
  # Instrument type
  instrument: InstrumentType!
}

# Execution event (sequence, step, or dataset events)
interface ExecutionEvent {
  # Event id
  id: ExecutionEventId!

  # Associated visit
  visitId: VisitId!

  # Observation whose execution produced this event
  observation: Observation!

  # Time at which this event was received
  received: Instant!
}

# ExecutionEvents in the current page
type ExecutionEventConnection {
  # The nodes in all the edges from the current page
  nodes: [ExecutionEvent!]!

  # Edges in the current page
  edges: [ExecutionEventEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# An ExecutionEvent and its cursor
type ExecutionEventEdge {
  # ExecutionEventEdge element
  node: ExecutionEvent!

  # ExecutionEventEdge element cursor
  cursor: Cursor!
}

# ExecutionEventId id formatted as `e-[1-9a-f][0-9a-f]*`
scalar ExecutionEventId

# State of being: either Deleted or Present
enum Existence {
  # Existence Present
  PRESENT

  # Existence Deleted
  DELETED
}

# Flux density entry
input FluxDensity {
  wavelength: WavelengthInput!
  density: PosBigDecimal!
}

type FluxDensityContinuumIntegrated {
  value: PosBigDecimal!
  units: FluxDensityContinuumIntegratedUnits!
}

# A flux density continuum value with integrated units
input FluxDensityContinuumIntegratedInput {
  value: PosBigDecimal!
  units: FluxDensityContinuumIntegratedUnits!
}

# Flux density continuum integrated units
enum FluxDensityContinuumIntegratedUnits {
  # W/m²/µm
  W_PER_M_SQUARED_PER_UM

  # erg/s/cm²/Å
  ERG_PER_S_PER_CM_SQUARED_PER_A
}

type FluxDensityContinuumSurface {
  value: PosBigDecimal!
  units: FluxDensityContinuumSurfaceUnits!
}

# A flux density continuum value with surface units
input FluxDensityContinuumSurfaceInput {
  value: PosBigDecimal!
  units: FluxDensityContinuumSurfaceUnits!
}

# Flux density continuum surface units
enum FluxDensityContinuumSurfaceUnits {
  # W/m²/µm/arcsec²
  W_PER_M_SQUARED_PER_UM_PER_ARCSEC_SQUARED

  # erg/s/cm²/Å/arcsec²
  ERG_PER_S_PER_CM_SQUARED_PER_A_PER_ARCSEC_SQUARED
}

type FluxDensityEntry {
  wavelength: Wavelength!
  density: PosBigDecimal!
}

# Focal plane Single/Multi/IFU
enum FocalPlane {
  # FocalPlane SingleSlit
  SINGLE_SLIT

  # FocalPlane MultipleSlit
  MULTIPLE_SLIT

  # FocalPlane IFU
  IFU
}

type focalPlaneAngle {
  # Focal plane angle in µas
  microarcseconds: Long!

  # Focal plane angle in mas
  milliarcseconds: BigDecimal!

  # Focal plane angle in arcsec
  arcseconds: BigDecimal!
}

# Focal plane angle source angle in appropriate units
input FocalPlaneAngleInput {
  microarcseconds: Long
  milliarcseconds: BigDecimal
  arcseconds: BigDecimal
}

# Galaxy spectrum
enum GalaxySpectrum {
  # GalaxySpectrum Elliptical
  ELLIPTICAL

  # GalaxySpectrum Spiral
  SPIRAL
}

# Create or edit a gaussian source.  Specify both "fwhm" and "spectralDefinition" when creating a new Gaussian.
input GaussianInput {
  # The fwhm field is required when creating a new instance of Gaussian, but optional when editing
  fwhm: AngleInput

  # The spectralDefinition field is required when creating a new instance of Gaussian, but optional when editing
  spectralDefinition: SpectralDefinitionIntegratedInput
}

# Gaussian source, one of bandNormalized and emissionLines will be defined.
type GaussianSource {
  # full width at half maximum
  fwhm: Angle!

  # Band normalized spectral definition
  bandNormalized: BandNormalizedIntegrated

  # Emission lines spectral definition
  emissionLines: EmissionLinesIntegrated
}

# GCAL calibration step (flat / arc)
type Gcal implements StepConfig {
  # GCAL continuum, present if no arcs are used
  continuum: GcalContinuum

  # GCAL arcs, one or more present if no continuum is used
  arcs: [GcalArc!]!

  # GCAL filter
  filter: GcalFilter!

  # GCAL diffuser
  diffuser: GcalDiffuser!

  # GCAL shutter
  shutter: GcalShutter!

  # Step type
  stepType: StepType!
}

# GCAL arc
enum GcalArc {
  # GcalArc ArArc
  AR_ARC

  # GcalArc ThArArc
  TH_AR_ARC

  # GcalArc CuArArc
  CU_AR_ARC

  # GcalArc XeArc
  XE_ARC
}

# GCAL configuration creation input
input GcalConfigurationInput {
  continuum: GcalContinuum
  arcs: [GcalArc!]!
  diffuser: GcalDiffuser!
  shutter: GcalShutter!
}

# GCAL continuum
enum GcalContinuum {
  # GcalContinuum IrGreyBodyLow
  IR_GREY_BODY_LOW

  # GcalContinuum IrGreyBodyHigh
  IR_GREY_BODY_HIGH

  # GcalContinuum QuartzHalogen
  QUARTZ_HALOGEN
}

# GCAL diffuser
enum GcalDiffuser {
  # GcalDiffuser Ir
  IR

  # GcalDiffuser Visible
  VISIBLE
}

# GCAL filter
enum GcalFilter {
  # GcalFilter None
  NONE

  # GcalFilter Gmos
  GMOS

  # GcalFilter Hros
  HROS

  # GcalFilter Nir
  NIR

  # GcalFilter Nd10
  ND10

  # GcalFilter Nd16
  ND16

  # GcalFilter Nd20
  ND20

  # GcalFilter Nd30
  ND30

  # GcalFilter Nd40
  ND40

  # GcalFilter Nd45
  ND45

  # GcalFilter Nd50
  ND50
}

# GCAL shutter
enum GcalShutter {
  # GcalShutter Open
  OPEN

  # GcalShutter Closed
  CLOSED
}

# GMOS amp count
enum GmosAmpCount {
  # GmosAmpCount Three
  THREE

  # GmosAmpCount Six
  SIX

  # GmosAmpCount Twelve
  TWELVE
}

# GMOS amp gain
enum GmosAmpGain {
  # GmosAmpGain Low
  LOW

  # GmosAmpGain High
  HIGH
}

# GMOS amp read mode
enum GmosAmpReadMode {
  # GmosAmpReadMode Slow
  SLOW

  # GmosAmpReadMode Fast
  FAST
}

# CCD Readout Configuration
type GmosCcdMode {
  # GMOS X-binning
  xBin: GmosXBinning!

  # GMOS Y-binning
  yBin: GmosYBinning!

  # GMOS Amp Count
  ampCount: GmosAmpCount!

  # GMOS Amp Gain
  ampGain: GmosAmpGain!

  # GMOS Amp Read Mode
  ampReadMode: GmosAmpReadMode!
}

# GMOS CCD readout input parameters
input GmosCcdReadoutInput {
  # X Binning
  xBin: GmosXBinning! = ONE

  # Y Binning
  yBin: GmosYBinning! = ONE

  # Amp Count
  ampCount: GmosAmpCount! = TWELVE

  # Amp Gain
  ampGain: GmosAmpGain! = LOW

  # Amp Read Mode
  ampRead: GmosAmpReadMode! = SLOW
}

# GMOS Custom Mask
type GmosCustomMask {
  # Custom Mask Filename
  filename: String!

  # Custom Slit Width
  slitWidth: GmosCustomSlitWidth!
}

# GMOS custom mask input parameters
input GmosCustomMaskInput {
  # Custom mask file name
  filename: String!

  # Custom mask slit width
  slitWidth: GmosCustomSlitWidth!
}

# GMOS Custom Slit Width
enum GmosCustomSlitWidth {
  # GmosCustomSlitWidth CustomWidth_0_25
  CUSTOM_WIDTH_0_25

  # GmosCustomSlitWidth CustomWidth_0_50
  CUSTOM_WIDTH_0_50

  # GmosCustomSlitWidth CustomWidth_0_75
  CUSTOM_WIDTH_0_75

  # GmosCustomSlitWidth CustomWidth_1_00
  CUSTOM_WIDTH_1_00

  # GmosCustomSlitWidth CustomWidth_1_50
  CUSTOM_WIDTH_1_50

  # GmosCustomSlitWidth CustomWidth_2_00
  CUSTOM_WIDTH_2_00

  # GmosCustomSlitWidth CustomWidth_5_00
  CUSTOM_WIDTH_5_00
}

# GMOS Detector Translation X Offset
enum GmosDtax {
  # GmosDtax MinusSix
  MINUS_SIX

  # GmosDtax MinusFive
  MINUS_FIVE

  # GmosDtax MinusFour
  MINUS_FOUR

  # GmosDtax MinusThree
  MINUS_THREE

  # GmosDtax MinusTwo
  MINUS_TWO

  # GmosDtax MinusOne
  MINUS_ONE

  # GmosDtax Zero
  ZERO

  # GmosDtax One
  ONE

  # GmosDtax Two
  TWO

  # GmosDtax Three
  THREE

  # GmosDtax Four
  FOUR

  # GmosDtax Five
  FIVE

  # GmosDtax Six
  SIX
}

# Electronic offsetting
enum GmosEOffsetting {
  # GmosEOffsetting On
  ON

  # GmosEOffsetting Off
  OFF
}

# GMOS grating order
enum GmosGratingOrder {
  # GmosGratingOrder Zero
  ZERO

  # GmosGratingOrder One
  ONE

  # GmosGratingOrder Two
  TWO
}

type GmosNodAndShuffle {
  # Offset position A
  posA: Offset!

  # Offset position B
  posB: Offset!

  # Whether to use electronic offsetting
  eOffset: GmosEOffsetting!

  # Shuffle offset
  shuffleOffset: Int!

  # Shuffle cycles
  shuffleCycles: Int!
}

# Creation input parameters for GMOS nod and shuffle
input GmosNodAndShuffleInput {
  # Offset position A
  posA: OffsetInput!

  # Offset position B
  posB: OffsetInput!

  # Electronic offsetting
  eOffset: GmosEOffsetting!

  # Shuffle offset
  shuffleOffset: Int!

  # Suffle cycles
  shuffleCycles: Int!
}

# GmosNorth atom, a collection of steps that should be executed in their entirety
type GmosNorthAtom implements Atom {
  # Individual steps that comprise the atom
  steps: [GmosNorthStep!]!

  # Time estimate for this atom's execution, the sum of each step's time.
  time: StepTime!

  # Atom id
  id: AtomId!
}

# GmosNorth bias step creation input
input GmosNorthBiasInput {
  # instrument configuration
  config: GmosNorthDynamicInput!
}

# GMOS North FPU
enum GmosNorthBuiltinFpu {
  # GmosNorthBuiltinFpu Ns0
  NS0

  # GmosNorthBuiltinFpu Ns1
  NS1

  # GmosNorthBuiltinFpu Ns2
  NS2

  # GmosNorthBuiltinFpu Ns3
  NS3

  # GmosNorthBuiltinFpu Ns4
  NS4

  # GmosNorthBuiltinFpu Ns5
  NS5

  # GmosNorthBuiltinFpu LongSlit_0_25
  LONG_SLIT_0_25

  # GmosNorthBuiltinFpu LongSlit_0_50
  LONG_SLIT_0_50

  # GmosNorthBuiltinFpu LongSlit_0_75
  LONG_SLIT_0_75

  # GmosNorthBuiltinFpu LongSlit_1_00
  LONG_SLIT_1_00

  # GmosNorthBuiltinFpu LongSlit_1_50
  LONG_SLIT_1_50

  # GmosNorthBuiltinFpu LongSlit_2_00
  LONG_SLIT_2_00

  # GmosNorthBuiltinFpu LongSlit_5_00
  LONG_SLIT_5_00

  # GmosNorthBuiltinFpu Ifu2Slits
  IFU2_SLITS

  # GmosNorthBuiltinFpu IfuBlue
  IFU_BLUE

  # GmosNorthBuiltinFpu IfuRed
  IFU_RED
}

# GmosNorth dark step creation input
input GmosNorthDarkInput {
  # instrument configuration
  config: GmosNorthDynamicInput!
}

# GmosNorth Detector type
enum GmosNorthDetector {
  # GmosNorthDetector E2V
  E2_V

  # GmosNorthDetector HAMAMATSU
  HAMAMATSU
}

# GMOS North dynamic step configuration
type GmosNorthDynamic {
  # GMOS exposure time
  exposure: Duration!

  # GMOS CCD Readout
  readout: GmosCcdMode!

  # GMOS detector x offset
  dtax: GmosDtax!

  # GMOS region of interest
  roi: GmosRoi!

  # GMOS North grating
  gratingConfig: GmosNorthGratingConfig

  # GMOS North filter
  filter: GmosNorthFilter

  # GMOS North FPU
  fpu: GmosNorthFpu
}

# GMOS North instrument configuration input
input GmosNorthDynamicInput {
  # Exposure time
  exposure: DurationInput!

  # GMOS CCD readout
  readout: GmosCcdReadoutInput!

  # GMOS detector x offset
  dtax: GmosDtax!

  # GMOS region of interest
  roi: GmosRoi!

  # GMOS North grating
  gratingConfig: GmosNorthGratingConfigInput

  # GMOS North filter
  filter: GmosNorthFilter

  # GMOS North FPU
  fpu: GmosNorthFpuInput
}

# GMOS North Execution Config
type GmosNorthExecutionConfig implements ExecutionConfig {
  # GMOS North static configuration
  static: GmosNorthStatic!

  # GMOS North acquisition execution
  acquisition: GmosNorthExecutionSequence!

  # GMOS North science execution
  science: GmosNorthExecutionSequence!
  visits(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): GmosNorthVisitRecordConnection!

  # Instrument type
  instrument: InstrumentType!
}

# Next atom to execute and potential future atoms
type GmosNorthExecutionSequence {
  # Next atom to execute, if any
  nextAtom: GmosNorthAtom

  # Remaining atoms to execute, if any
  possibleFuture: [GmosNorthAtom!]!
}

# GMOS North Filter
enum GmosNorthFilter {
  # GmosNorthFilter GPrime
  G_PRIME

  # GmosNorthFilter RPrime
  R_PRIME

  # GmosNorthFilter IPrime
  I_PRIME

  # GmosNorthFilter ZPrime
  Z_PRIME

  # GmosNorthFilter Z
  Z

  # GmosNorthFilter Y
  Y

  # GmosNorthFilter GG455
  GG455

  # GmosNorthFilter OG515
  OG515

  # GmosNorthFilter RG610
  RG610

  # GmosNorthFilter CaT
  CA_T

  # GmosNorthFilter Ha
  HA

  # GmosNorthFilter HaC
  HA_C

  # GmosNorthFilter DS920
  DS920

  # GmosNorthFilter SII
  SII

  # GmosNorthFilter OIII
  OIII

  # GmosNorthFilter OIIIC
  OIIIC

  # GmosNorthFilter HeII
  HE_II

  # GmosNorthFilter HeIIC
  HE_IIC

  # GmosNorthFilter HartmannA_RPrime
  HARTMANN_A_R_PRIME

  # GmosNorthFilter HartmannB_RPrime
  HARTMANN_B_R_PRIME

  # GmosNorthFilter GPrime_GG455
  G_PRIME_GG455

  # GmosNorthFilter GPrime_OG515
  G_PRIME_OG515

  # GmosNorthFilter RPrime_RG610
  R_PRIME_RG610

  # GmosNorthFilter IPrime_CaT
  I_PRIME_CA_T

  # GmosNorthFilter ZPrime_CaT
  Z_PRIME_CA_T

  # GmosNorthFilter UPrime
  U_PRIME
}

# GMOS North FPU option, either builtin or custom mask
type GmosNorthFpu {
  # The custom mask, if in use
  customMask: GmosCustomMask

  # GMOS North builtin FPU, if in use
  builtin: GmosNorthBuiltinFpu
}

# GMOS North FPU input parameters (choose custom or builtin).
input GmosNorthFpuInput {
  # Custom mask FPU option
  customMask: GmosCustomMaskInput

  # Builtin FPU option
  builtin: GmosNorthBuiltinFpu
}

# GmosNorth GCAL step creation input
input GmosNorthGcalInput {
  # instrument configuration
  config: GmosNorthDynamicInput!

  # GCAL configuration
  gcalConfig: GcalConfigurationInput!
}

# GMOS North Grating
enum GmosNorthGrating {
  # GmosNorthGrating B1200_G5301
  B1200_G5301

  # GmosNorthGrating R831_G5302
  R831_G5302

  # GmosNorthGrating B600_G5303
  B600_G5303

  # GmosNorthGrating B600_G5307
  B600_G5307

  # GmosNorthGrating R600_G5304
  R600_G5304

  # GmosNorthGrating B480_G5309
  B480_G5309

  # GmosNorthGrating R400_G5305
  R400_G5305

  # GmosNorthGrating R150_G5306
  R150_G5306

  # GmosNorthGrating R150_G5308
  R150_G5308
}

# GMOS North Grating Configuration
type GmosNorthGratingConfig {
  # GMOS North Grating
  grating: GmosNorthGrating!

  # GMOS grating order
  order: GmosGratingOrder!

  # Grating wavelength
  wavelength: Wavelength!
}

# GMOS North grating input parameters
input GmosNorthGratingConfigInput {
  # GmosGmosNorth grating
  grating: GmosNorthGrating!

  # GMOS grating order
  order: GmosGratingOrder!

  # Grating wavelength
  wavelength: WavelengthInput!
}

# GMOS North Long Slit mode
type GmosNorthLongSlit {
  # GMOS North Long Slit basic configuration
  basic: GmosNorthLongSlitBasic!

  # GMOS North Long Slit advanced configuration
  advanced: GmosNorthLongSlitAdvanced
}

# GMOS North Long Slit advanced configuration
type GmosNorthLongSlitAdvanced {
  # GMOS North Grating override, taking the place of the basic configuration grating
  overrideGrating: GmosNorthGrating

  # GMOS North filter override, taking the place of the basic configuration filter
  overrideFilter: GmosNorthFilter

  # GMOS North FPU override, taking the place of the basic configuration FPU
  overrideFpu: GmosNorthBuiltinFpu

  # Explicitly specified GMOS X-Binning, override the default (calculated from effective slit size)
  explicitXBin: GmosXBinning

  # Explicitly specified GMOS Y-Binning, override the default (TWO)
  explicitYBin: GmosYBinning

  # Explicitly specified GMOS amp read mode, override the default (SLOW)
  explicitAmpReadMode: GmosAmpReadMode

  # Explicitly specified GMOS amp gain, override the default (LOW)
  explicitAmpGain: GmosAmpGain

  # Explicitly specified GMOS ROI, overriding the default (FULL_FRAME)
  explicitRoi: GmosRoi

  # Explicitly specified wavelength dithers required to fill in the chip gaps (in
  # nm), taking the place of the calculated value based on the grating dispersion
  explicitWavelengthDithers: [Int!]

  # Explicitly specified spatial q offsets, overriding the default
  explicitSpatialOffsets: [q!]
}

# Edit or create GMOS North Long Slit advanced configuration
input GmosNorthLongSlitAdvancedConfigInput {
  # The overrideGrating field may be unset by assigning a null value, or ignored by skipping it altogether
  overrideGrating: GmosNorthGrating

  # The overrideFilter field may be unset by assigning a null value, or ignored by skipping it altogether
  overrideFilter: GmosNorthFilter

  # The overrideFpu field may be unset by assigning a null value, or ignored by skipping it altogether
  overrideFpu: GmosNorthBuiltinFpu

  # The explicitXBin field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitXBin: GmosXBinning

  # The explicitYBin field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitYBin: GmosYBinning

  # The explicitAmpReadMode field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitAmpReadMode: GmosAmpReadMode

  # The explicitAmpGain field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitAmpGain: GmosAmpGain

  # The explicitRoi field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitRoi: GmosRoi

  # The explicitWavelengthDithers field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitWavelengthDithers: [Int!]

  # The explicitSpatialOffsets field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitSpatialOffsets: [OffsetComponentInput!]
}

# GMOS North Long Slit basic configuration
type GmosNorthLongSlitBasic {
  # GMOS North Grating
  grating: GmosNorthGrating!

  # GMOS North Filter
  filter: GmosNorthFilter

  # GMOS North FPU
  fpu: GmosNorthBuiltinFpu!
}

# Edit or create GMOS North Long Slit basic configuration
input GmosNorthLongSlitBasicConfigInput {
  # The grating field must be either specified or skipped altogether.  It cannot be unset with a null value.
  grating: GmosNorthGrating

  # The filter field may be unset by assigning a null value, or ignored by skipping it altogether
  filter: GmosNorthFilter

  # The fpu field must be either specified or skipped altogether.  It cannot be unset with a null value.
  fpu: GmosNorthBuiltinFpu
}

# Edit or create GMOS North Long Slit configuration
input GmosNorthLongSlitInput {
  # The basic field must be either specified or skipped altogether.  It cannot be unset with a null value.
  basic: GmosNorthLongSlitBasicConfigInput

  # The advanced field may be unset by assigning a null value, or ignored by skipping it altogether
  advanced: GmosNorthLongSlitAdvancedConfigInput
}

# GMOS North Manual Configuration
type GmosNorthManualConfig implements ManualConfig {
  # Static/unchanging configuration
  static: GmosNorthStatic!

  # Acquisition sequence.
  acquisition: GmosNorthSequence!

  # Science sequence.
  science: GmosNorthSequence!

  # Instrument type
  instrument: InstrumentType!

  # Planned time for this configuration
  plannedTime: PlannedTime!
}

# GmosNorth science step creation input
input GmosNorthScienceInput {
  # instrument configuration
  config: GmosNorthDynamicInput!

  # offset position
  offset: OffsetInput!
}

# A series of GmosNorth atoms that comprise the sequence
type GmosNorthSequence {
  # Sequence atoms
  atoms: [GmosNorthAtom!]!

  # Time required for the full execution of this sequence
  time: StepTime!
}

# GMOS North stage mode
enum GmosNorthStageMode {
  # GmosNorthStageMode NoFollow
  NO_FOLLOW

  # GmosNorthStageMode FollowXyz
  FOLLOW_XYZ

  # GmosNorthStageMode FollowXy
  FOLLOW_XY

  # GmosNorthStageMode FollowZ
  FOLLOW_Z
}

# Unchanging (over the course of the sequence) configuration values
type GmosNorthStatic {
  # Stage mode
  stageMode: GmosNorthStageMode!

  # Detector in use (always HAMAMATSU for recent and new observations)
  detector: GmosNorthDetector!

  # Is MOS Pre-Imaging Observation
  mosPreImaging: MosPreImaging!

  # Nod-and-shuffle configuration
  nodAndShuffle: GmosNodAndShuffle
}

# GMOS North static configuration input parameters
input GmosNorthStaticInput {
  # GMOS North Detector option
  detector: GmosNorthDetector! = HAMAMATSU

  # Whether this is a MOS pre-imaging observation
  mosPreImaging: MosPreImaging! = IS_NOT_MOS_PRE_IMAGING

  # GMOS Nod And Shuffle configuration
  nodAndShuffle: GmosNodAndShuffleInput

  # GMOS North Stage Mode
  stageMode: GmosNorthStageMode! = FOLLOW_XY
}

# GmosNorth step with potential breakpoint
type GmosNorthStep implements Step {
  # Instrument configuration for this step
  instrumentConfig: GmosNorthDynamic!

  # Step id
  id: StepId!

  # Whether to pause before the execution of this step
  breakpoint: Breakpoint!

  # The sequence step itself
  stepConfig: StepConfig!

  # Time estimate for this step's execution
  time: StepTime!
}

# GmosNorth step creation input.  Choose exactly one step type.
input GmosNorthStepInput {
  # Bias step creation option
  bias: GmosNorthBiasInput

  # Dark step creation option
  dark: GmosNorthDarkInput

  # GCAL step creation option
  gcal: GmosNorthGcalInput

  # Science step creation option
  science: GmosNorthScienceInput
}

# A GmosNorth step configuration as recorded by Observe
type GmosNorthStepRecord {
  # Step id
  id: StepId!

  # Visit id
  visitId: VisitId!

  # Created by Observe at time
  created: Instant!

  # Started at time
  startTime: Instant

  # Ended at time
  endTime: Instant

  # Step duration
  duration: Duration!

  # GmosNorth configuration for this step
  instrumentConfig: GmosNorthDynamic!

  # The executed step itself
  stepConfig: StepConfig!

  # Step events associated with this step
  stepEvents(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): StepEventConnection!

  # Step QA state based on a combination of dataset QA states
  stepQaState: StepQaState

  # Dataset events associated with this step
  datasetEvents(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): DatasetEventConnection!

  # Datasets associated with this step
  datasets(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): DatasetConnection!
}

# Steps recorded by Observe in the current page
type GmosNorthStepRecordConnection {
  # The nodes in all the edges from the current page
  nodes: [GmosNorthStepRecord!]!

  # Edges in the current page
  edges: [GmosNorthStepRecordEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# A step recorded by Observe and its cursor
type GmosNorthStepRecordEdge {
  # GmosNorthStepRecordEdge element
  node: GmosNorthStepRecord!

  # GmosNorthStepRecordEdge element cursor
  cursor: Cursor!
}

# Input parameters for creating a new GmosNorth StepRecord
input GmosNorthStepRecordInput {
  observationId: ObservationId!
  visitId: VisitId!
  stepConfig: GmosNorthStepInput!
}

# A GmosNorth visit as recorded by Observe
type GmosNorthVisitRecord {
  # Visit id
  id: VisitId!

  # Created by Observe at time
  created: Instant!

  # Started at time
  startTime: Instant

  # Ended at time
  endTime: Instant

  # Step duration
  duration: Duration!

  # GmosNorth static instrument configuration
  staticConfig: GmosNorthStatic!

  # GmosNorth recorded steps
  steps(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): GmosNorthStepRecordConnection!

  # Sequence events associated with this visit
  sequenceEvents(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): SequenceEventConnection!
}

# Visits as recorded by Observe
type GmosNorthVisitRecordConnection {
  # The nodes in all the edges from the current page
  nodes: [GmosNorthVisitRecord!]!

  # Edges in the current page
  edges: [GmosNorthVisitRecordEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# A visit (and its cursor) as recorded by Observe
type GmosNorthVisitRecordEdge {
  # GmosNorthVisitRecordEdge element
  node: GmosNorthVisitRecord!

  # GmosNorthVisitRecordEdge element cursor
  cursor: Cursor!
}

# Input parameters for creating a new GmosNorth VisitRecord
input GmosNorthVisitRecordInput {
  observationId: ObservationId!
  static: GmosNorthStaticInput!
}

# GMOS Region Of Interest
enum GmosRoi {
  # GmosRoi FullFrame
  FULL_FRAME

  # GmosRoi Ccd2
  CCD2

  # GmosRoi CentralSpectrum
  CENTRAL_SPECTRUM

  # GmosRoi CentralStamp
  CENTRAL_STAMP

  # GmosRoi TopSpectrum
  TOP_SPECTRUM

  # GmosRoi BottomSpectrum
  BOTTOM_SPECTRUM

  # GmosRoi Custom
  CUSTOM
}

# GmosSouth atom, a collection of steps that should be executed in their entirety
type GmosSouthAtom implements Atom {
  # Individual steps that comprise the atom
  steps: [GmosSouthStep!]!

  # Time estimate for this atom's execution, the sum of each step's time.
  time: StepTime!

  # Atom id
  id: AtomId!
}

# GmosSouth bias step creation input
input GmosSouthBiasInput {
  # instrument configuration
  config: GmosSouthDynamicInput!
}

# GMOS South FPU
enum GmosSouthBuiltinFpu {
  # GmosSouthBuiltinFpu Bhros
  BHROS

  # GmosSouthBuiltinFpu Ns1
  NS1

  # GmosSouthBuiltinFpu Ns2
  NS2

  # GmosSouthBuiltinFpu Ns3
  NS3

  # GmosSouthBuiltinFpu Ns4
  NS4

  # GmosSouthBuiltinFpu Ns5
  NS5

  # GmosSouthBuiltinFpu LongSlit_0_25
  LONG_SLIT_0_25

  # GmosSouthBuiltinFpu LongSlit_0_50
  LONG_SLIT_0_50

  # GmosSouthBuiltinFpu LongSlit_0_75
  LONG_SLIT_0_75

  # GmosSouthBuiltinFpu LongSlit_1_00
  LONG_SLIT_1_00

  # GmosSouthBuiltinFpu LongSlit_1_50
  LONG_SLIT_1_50

  # GmosSouthBuiltinFpu LongSlit_2_00
  LONG_SLIT_2_00

  # GmosSouthBuiltinFpu LongSlit_5_00
  LONG_SLIT_5_00

  # GmosSouthBuiltinFpu Ifu2Slits
  IFU2_SLITS

  # GmosSouthBuiltinFpu IfuBlue
  IFU_BLUE

  # GmosSouthBuiltinFpu IfuRed
  IFU_RED

  # GmosSouthBuiltinFpu IfuNS2Slits
  IFU_NS2_SLITS

  # GmosSouthBuiltinFpu IfuNSBlue
  IFU_NS_BLUE

  # GmosSouthBuiltinFpu IfuNSRed
  IFU_NS_RED
}

# GmosSouth dark step creation input
input GmosSouthDarkInput {
  # instrument configuration
  config: GmosSouthDynamicInput!
}

# GmosSouth Detector type
enum GmosSouthDetector {
  # GmosSouthDetector E2V
  E2_V

  # GmosSouthDetector HAMAMATSU
  HAMAMATSU
}

# GMOS South dynamic step configuration
type GmosSouthDynamic {
  # GMOS exposure time
  exposure: Duration!

  # GMOS CCD Readout
  readout: GmosCcdMode!

  # GMOS detector x offset
  dtax: GmosDtax!

  # GMOS region of interest
  roi: GmosRoi!

  # GMOS South grating
  gratingConfig: GmosSouthGratingConfig

  # GMOS South filter
  filter: GmosSouthFilter

  # GMOS South FPU
  fpu: GmosSouthFpu
}

# GMOS South instrument configuration input
input GmosSouthDynamicInput {
  # Exposure time
  exposure: DurationInput!

  # GMOS CCD readout
  readout: GmosCcdReadoutInput!

  # GMOS detector x offset
  dtax: GmosDtax!

  # GMOS region of interest
  roi: GmosRoi!

  # GMOS South grating
  gratingConfig: GmosSouthGratingConfigInput

  # GMOS South filter
  filter: GmosSouthFilter

  # GMOS South FPU
  fpu: GmosSouthFpuInput
}

# GMOS South Execution Config
type GmosSouthExecutionConfig implements ExecutionConfig {
  # GMOS South static configuration
  static: GmosSouthStatic!

  # GMOS South acquisition execution
  acquisition: GmosSouthExecutionSequence!

  # GMOS South science execution
  science: GmosSouthExecutionSequence!
  visits(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): GmosSouthVisitRecordConnection!

  # Instrument type
  instrument: InstrumentType!
}

# Next atom to execute and potential future atoms
type GmosSouthExecutionSequence {
  # Next atom to execute, if any
  nextAtom: GmosSouthAtom

  # Remaining atoms to execute, if any
  possibleFuture: [GmosSouthAtom!]!
}

# GMOS South Filter
enum GmosSouthFilter {
  # GmosSouthFilter UPrime
  U_PRIME

  # GmosSouthFilter GPrime
  G_PRIME

  # GmosSouthFilter RPrime
  R_PRIME

  # GmosSouthFilter IPrime
  I_PRIME

  # GmosSouthFilter ZPrime
  Z_PRIME

  # GmosSouthFilter Z
  Z

  # GmosSouthFilter Y
  Y

  # GmosSouthFilter GG455
  GG455

  # GmosSouthFilter OG515
  OG515

  # GmosSouthFilter RG610
  RG610

  # GmosSouthFilter RG780
  RG780

  # GmosSouthFilter CaT
  CA_T

  # GmosSouthFilter HartmannA_RPrime
  HARTMANN_A_R_PRIME

  # GmosSouthFilter HartmannB_RPrime
  HARTMANN_B_R_PRIME

  # GmosSouthFilter GPrime_GG455
  G_PRIME_GG455

  # GmosSouthFilter GPrime_OG515
  G_PRIME_OG515

  # GmosSouthFilter RPrime_RG610
  R_PRIME_RG610

  # GmosSouthFilter IPrime_RG780
  I_PRIME_RG780

  # GmosSouthFilter IPrime_CaT
  I_PRIME_CA_T

  # GmosSouthFilter ZPrime_CaT
  Z_PRIME_CA_T

  # GmosSouthFilter Ha
  HA

  # GmosSouthFilter SII
  SII

  # GmosSouthFilter HaC
  HA_C

  # GmosSouthFilter OIII
  OIII

  # GmosSouthFilter OIIIC
  OIIIC

  # GmosSouthFilter HeII
  HE_II

  # GmosSouthFilter HeIIC
  HE_IIC

  # GmosSouthFilter Lya395
  LYA395
}

# GMOS South FPU option, either builtin or custom mask
type GmosSouthFpu {
  # The custom mask, if in use
  customMask: GmosCustomMask

  # GMOS South builtin FPU, if in use
  builtin: GmosSouthBuiltinFpu
}

# GMOS South FPU input parameters (choose custom or builtin).
input GmosSouthFpuInput {
  # Custom mask FPU option
  customMask: GmosCustomMaskInput

  # Builtin FPU option
  builtin: GmosSouthBuiltinFpu
}

# GmosSouth GCAL step creation input
input GmosSouthGcalInput {
  # instrument configuration
  config: GmosSouthDynamicInput!

  # GCAL configuration
  gcalConfig: GcalConfigurationInput!
}

# GMOS South Grating
enum GmosSouthGrating {
  # GmosSouthGrating B1200_G5321
  B1200_G5321

  # GmosSouthGrating R831_G5322
  R831_G5322

  # GmosSouthGrating B600_G5323
  B600_G5323

  # GmosSouthGrating R600_G5324
  R600_G5324

  # GmosSouthGrating B480_G5327
  B480_G5327

  # GmosSouthGrating R400_G5325
  R400_G5325

  # GmosSouthGrating R150_G5326
  R150_G5326
}

# GMOS South Grating Configuration
type GmosSouthGratingConfig {
  # GMOS South Grating
  grating: GmosSouthGrating!

  # GMOS grating order
  order: GmosGratingOrder!

  # Grating wavelength
  wavelength: Wavelength!
}

# GMOS South grating input parameters
input GmosSouthGratingConfigInput {
  # GmosGmosSouth grating
  grating: GmosSouthGrating!

  # GMOS grating order
  order: GmosGratingOrder!

  # Grating wavelength
  wavelength: WavelengthInput!
}

# GMOS South Long Slit mode
type GmosSouthLongSlit {
  # GMOS South Long Slit basic configuration
  basic: GmosSouthLongSlitBasic!

  # GMOS South Long Slit advanced configuration
  advanced: GmosSouthLongSlitAdvanced
}

# GMOS South Long Slit advanced configuration
type GmosSouthLongSlitAdvanced {
  # GMOS North Grating override, taking the place of the basic configuration grating
  overrideGrating: GmosSouthGrating

  # GMOS North filter override, taking the place of the basic configuration filter
  overrideFilter: GmosSouthFilter

  # GMOS North FPU override, taking the place of the basic configuration FPU
  overrideFpu: GmosSouthBuiltinFpu

  # Explicitly specified GMOS X-Binning, override the default (calculated from effective slit size)
  explicitXBin: GmosXBinning

  # Explicitly specified GMOS Y-Binning, override the default (TWO)
  explicitYBin: GmosYBinning

  # Explicitly specified GMOS amp read mode, override the default (SLOW)
  explicitAmpReadMode: GmosAmpReadMode

  # Explicitly specified GMOS amp gain, override the default (LOW)
  explicitAmpGain: GmosAmpGain

  # Explicitly specified GMOS ROI, overriding the default (FULL_FRAME)
  explicitRoi: GmosRoi

  # Explicitly specified wavelength dithers required to fill in the chip gaps (in
  # nm), taking the place of the calculated value based on the grating dispersion
  explicitWavelengthDithers: [Int!]

  # Explicitly specified spatial q offsets, overriding the default
  explicitSpatialOffsets: [q!]
}

# Edit or create GMOS South Long Slit advanced configuration
input GmosSouthLongSlitAdvancedConfigInput {
  # The overrideGrating field may be unset by assigning a null value, or ignored by skipping it altogether
  overrideGrating: GmosSouthGrating

  # The overrideFilter field may be unset by assigning a null value, or ignored by skipping it altogether
  overrideFilter: GmosSouthFilter

  # The overrideFpu field may be unset by assigning a null value, or ignored by skipping it altogether
  overrideFpu: GmosSouthBuiltinFpu

  # The explicitXBin field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitXBin: GmosXBinning

  # The explicitYBin field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitYBin: GmosYBinning

  # The explicitAmpReadMode field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitAmpReadMode: GmosAmpReadMode

  # The explicitAmpGain field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitAmpGain: GmosAmpGain

  # The explicitRoi field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitRoi: GmosRoi

  # The explicitWavelengthDithers field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitWavelengthDithers: [Int!]

  # The explicitSpatialOffsets field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitSpatialOffsets: [OffsetComponentInput!]
}

# GMOS South Long Slit basic configuration
type GmosSouthLongSlitBasic {
  # GMOS North Grating
  grating: GmosSouthGrating!

  # GMOS North Filter
  filter: GmosSouthFilter

  # GMOS North FPU
  fpu: GmosSouthBuiltinFpu!
}

# Edit or create GMOS South Long Slit basic configuration
input GmosSouthLongSlitBasicConfigInput {
  # The grating field must be either specified or skipped altogether.  It cannot be unset with a null value.
  grating: GmosSouthGrating

  # The filter field may be unset by assigning a null value, or ignored by skipping it altogether
  filter: GmosSouthFilter

  # The fpu field must be either specified or skipped altogether.  It cannot be unset with a null value.
  fpu: GmosSouthBuiltinFpu
}

# Edit or create GMOS South Long Slit configuration
input GmosSouthLongSlitInput {
  # The basic field must be either specified or skipped altogether.  It cannot be unset with a null value.
  basic: GmosSouthLongSlitBasicConfigInput

  # The advanced field may be unset by assigning a null value, or ignored by skipping it altogether
  advanced: GmosSouthLongSlitAdvancedConfigInput
}

# GMOS South Manual Configuration
type GmosSouthManualConfig implements ManualConfig {
  # Static/unchanging configuration
  static: GmosSouthStatic!

  # Acquisition sequence.
  acquisition: GmosSouthSequence!

  # Science sequence.
  science: GmosSouthSequence!

  # Instrument type
  instrument: InstrumentType!

  # Planned time for this configuration
  plannedTime: PlannedTime!
}

# GmosSouth science step creation input
input GmosSouthScienceInput {
  # instrument configuration
  config: GmosSouthDynamicInput!

  # offset position
  offset: OffsetInput!
}

# A series of GmosSouth atoms that comprise the sequence
type GmosSouthSequence {
  # Sequence atoms
  atoms: [GmosSouthAtom!]!

  # Time required for the full execution of this sequence
  time: StepTime!
}

# GMOS South stage mode
enum GmosSouthStageMode {
  # GmosSouthStageMode NoFollow
  NO_FOLLOW

  # GmosSouthStageMode FollowXyz
  FOLLOW_XYZ

  # GmosSouthStageMode FollowXy
  FOLLOW_XY

  # GmosSouthStageMode FollowZ
  FOLLOW_Z
}

# Unchanging (over the course of the sequence) configuration values
type GmosSouthStatic {
  # Stage mode
  stageMode: GmosSouthStageMode!

  # Detector in use (always HAMAMATSU for recent and new observations)
  detector: GmosSouthDetector!

  # Is MOS Pre-Imaging Observation
  mosPreImaging: MosPreImaging!

  # Nod-and-shuffle configuration
  nodAndShuffle: GmosNodAndShuffle
}

# GMOS South static configuration input parameters
input GmosSouthStaticInput {
  # GMOS North Detector option
  detector: GmosNorthDetector! = HAMAMATSU

  # Whether this is a MOS pre-imaging observation
  mosPreImaging: MosPreImaging! = IS_NOT_MOS_PRE_IMAGING

  # GMOS Nod And Shuffle configuration
  nodAndShuffle: GmosNodAndShuffleInput

  # GMOS North Stage Mode
  stageMode: GmosSouthStageMode! = FOLLOW_XY
}

# GmosSouth step with potential breakpoint
type GmosSouthStep implements Step {
  # Instrument configuration for this step
  instrumentConfig: GmosSouthDynamic!

  # Step id
  id: StepId!

  # Whether to pause before the execution of this step
  breakpoint: Breakpoint!

  # The sequence step itself
  stepConfig: StepConfig!

  # Time estimate for this step's execution
  time: StepTime!
}

# GmosSouth step creation input.  Choose exactly one step type.
input GmosSouthStepInput {
  # Bias step creation option
  bias: GmosSouthBiasInput

  # Dark step creation option
  dark: GmosSouthDarkInput

  # GCAL step creation option
  gcal: GmosSouthGcalInput

  # Science step creation option
  science: GmosSouthScienceInput
}

# A GmosSouth step configuration as recorded by Observe
type GmosSouthStepRecord {
  # Step id
  id: StepId!

  # Visit id
  visitId: VisitId!

  # Created by Observe at time
  created: Instant!

  # Started at time
  startTime: Instant

  # Ended at time
  endTime: Instant

  # Step duration
  duration: Duration!

  # GmosSouth configuration for this step
  instrumentConfig: GmosSouthDynamic!

  # The executed step itself
  stepConfig: StepConfig!

  # Step events associated with this step
  stepEvents(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): StepEventConnection!

  # Step QA state based on a combination of dataset QA states
  stepQaState: StepQaState

  # Dataset events associated with this step
  datasetEvents(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): DatasetEventConnection!

  # Datasets associated with this step
  datasets(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): DatasetConnection!
}

# Steps recorded by Observe in the current page
type GmosSouthStepRecordConnection {
  # The nodes in all the edges from the current page
  nodes: [GmosSouthStepRecord!]!

  # Edges in the current page
  edges: [GmosSouthStepRecordEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# A step recorded by Observe and its cursor
type GmosSouthStepRecordEdge {
  # GmosSouthStepRecordEdge element
  node: GmosSouthStepRecord!

  # GmosSouthStepRecordEdge element cursor
  cursor: Cursor!
}

# Input parameters for creating a new GmosSouth StepRecord
input GmosSouthStepRecordInput {
  observationId: ObservationId!
  visitId: VisitId!
  stepConfig: GmosSouthStepInput!
}

# A GmosSouth visit as recorded by Observe
type GmosSouthVisitRecord {
  # Visit id
  id: VisitId!

  # Created by Observe at time
  created: Instant!

  # Started at time
  startTime: Instant

  # Ended at time
  endTime: Instant

  # Step duration
  duration: Duration!

  # GmosSouth static instrument configuration
  staticConfig: GmosSouthStatic!

  # GmosSouth recorded steps
  steps(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): GmosSouthStepRecordConnection!

  # Sequence events associated with this visit
  sequenceEvents(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): SequenceEventConnection!
}

# Visits as recorded by Observe
type GmosSouthVisitRecordConnection {
  # The nodes in all the edges from the current page
  nodes: [GmosSouthVisitRecord!]!

  # Edges in the current page
  edges: [GmosSouthVisitRecordEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# A visit (and its cursor) as recorded by Observe
type GmosSouthVisitRecordEdge {
  # GmosSouthVisitRecordEdge element
  node: GmosSouthVisitRecord!

  # GmosSouthVisitRecordEdge element cursor
  cursor: Cursor!
}

# Input parameters for creating a new GmosSouth VisitRecord
input GmosSouthVisitRecordInput {
  observationId: ObservationId!
  static: GmosSouthStaticInput!
}

# GMOS X Binning
enum GmosXBinning {
  # GmosXBinning One
  ONE

  # GmosXBinning Two
  TWO

  # GmosXBinning Four
  FOUR
}

# GMOS Y Binning
enum GmosYBinning {
  # GmosYBinning One
  ONE

  # GmosYBinning Two
  TWO

  # GmosYBinning Four
  FOUR
}

# HII Region spectrum
enum HiiRegionSpectrum {
  # HiiRegionSpectrum OrionNebula
  ORION_NEBULA
}

# Target right ascension coordinate in format 'HH:MM:SS.sss'
scalar HmsString

type HourAngleRange {
  # Minimum Hour Angle (hours)
  minHours: BigDecimal!

  # Maximum Hour Angle (hours)
  maxHours: BigDecimal!
}

# Hour angle range creation parameters
input HourAngleRangeInput {
  minHours: BigDecimal
  maxHours: BigDecimal
}

# Image quality
enum ImageQuality {
  # ImageQuality PointOne
  POINT_ONE

  # ImageQuality PointTwo
  POINT_TWO

  # ImageQuality PointThree
  POINT_THREE

  # ImageQuality PointFour
  POINT_FOUR

  # ImageQuality PointSix
  POINT_SIX

  # ImageQuality PointEight
  POINT_EIGHT

  # ImageQuality OnePointZero
  ONE_POINT_ZERO

  # ImageQuality OnePointFive
  ONE_POINT_FIVE

  # ImageQuality TwoPointZero
  TWO_POINT_ZERO
}

# Instant of time in ISO-8601 representation in format '2011-12-03T10:15:30Z'
scalar Instant

# Instrument
enum InstrumentType {
  # InstrumentType AcqCam
  ACQ_CAM

  # InstrumentType Bhros
  BHROS

  # InstrumentType Flamingos2
  FLAMINGOS2

  # InstrumentType Ghost
  GHOST

  # InstrumentType GmosNorth
  GMOS_NORTH

  # InstrumentType GmosSouth
  GMOS_SOUTH

  # InstrumentType Gnirs
  GNIRS

  # InstrumentType Gpi
  GPI

  # InstrumentType Gsaoi
  GSAOI

  # InstrumentType Michelle
  MICHELLE

  # InstrumentType Nici
  NICI

  # InstrumentType Nifs
  NIFS

  # InstrumentType Niri
  NIRI

  # InstrumentType Phoenix
  PHOENIX

  # InstrumentType Trecs
  TRECS

  # InstrumentType Visitor
  VISITOR

  # InstrumentType Scorpio
  SCORPIO

  # InstrumentType Alopeke
  ALOPEKE

  # InstrumentType Zorro
  ZORRO
}

type ItcSuccess {
  exposureTime: Duration!
  exposures: Int!
  signalToNoise: PosBigDecimal!
}

type LineFluxIntegrated {
  value: PosBigDecimal!
  units: LineFluxIntegratedUnits!
}

# A line flux value with integrated units
input LineFluxIntegratedInput {
  value: PosBigDecimal!
  units: LineFluxIntegratedUnits!
}

# Line flux integrated units
enum LineFluxIntegratedUnits {
  # W/m²
  W_PER_M_SQUARED

  # erg/s/cm²
  ERG_PER_S_PER_CM_SQUARED
}

type LineFluxSurface {
  value: PosBigDecimal!
  units: LineFluxSurfaceUnits!
}

# A line flux value with surface units
input LineFluxSurfaceInput {
  value: PosBigDecimal!
  units: LineFluxSurfaceUnits!
}

# Line flux surface units
enum LineFluxSurfaceUnits {
  # W/m²/arcsec²
  W_PER_M_SQUARED_PER_ARCSEC_SQUARED

  # erg/s/cm²/arcsec²
  ERG_PER_S_PER_CM_SQUARED_PER_ARCSEC_SQUARED
}

# The `Long` scalar type represents non-fractional signed whole numeric values.
# Long can represent values between -(2^63) and 2^63 - 1.
scalar Long

# Create an angle from a signed integral value and its units.
input LongAngleInput {
  value: Long!
  units: AngleUnits!
}

# Manual observing sequence and instrument configuration
interface ManualConfig {
  # Instrument type
  instrument: InstrumentType!

  # Planned time for this configuration
  plannedTime: PlannedTime!
}

# MOS pre-imaging observation
enum MosPreImaging {
  # MosPreImaging IsMosPreImaging
  IS_MOS_PRE_IMAGING

  # MosPreImaging IsNotMosPreImaging
  IS_NOT_MOS_PRE_IMAGING
}

type Mutation {
  # Adds a new dataset event associated with the given visit.  The
  # generation of a single dataset will produce multiple events as it
  # transitions through the observe, readout and write stages.
  #       
  addDatasetEvent(
    # Describes the dataset event to add.  All events are associated with a
    # particular visit (see 'record{InstrumentName}Visit').  Dataset events
    # are further associated with an |observation, step and index because a
    # step may produce multiple datasets.  The three form its 'location'.
    # (See also 'record{InstrumentName}Step'.) Each dataset event 'payload'
    # identifies the stage (observe, readout, or write) and possibly the
    # dataset filename.
    #       
    input: AddDatasetEventInput!
  ): DatasetEvent!

  # Adds a sequence event associated with the given visit. Multiple events
  # will be produced during the execution of a sequence as it is started,
  # paused, continued, etc.
  #       
  addSequenceEvent(
    # Describes the sequence event to add.  All events are associated with a
    # particular visit (see 'record{InstrumentName}Visit').  Sequence events
    # are further associated with an observation (i.e., its 'location').
    # Each sequence event 'payload' identifies the sequence command that
    # acted upon the sequence.
    #       
    input: AddSequenceEventInput!
  ): SequenceEvent!

  # Adds a new step event associated with the given visit. Multiple events
  # will be produced during the execution of a single step as it
  # transitions through configure and observe stages.
  #       
  addStepEvent(
    # Describes the step event to add.  All events are associated with a
    # particular visit (see 'record{InstrumentName}Visit'.  Step events are
    # further associated with an observation and step (i.e., its 'location').
    # (See also 'record{InstrumentName}Step'.) Each step event 'payload'
    # identifies the sequence type (acquisition or science) and the stage
    # through which the step execution is passing.
    #       
    input: AddStepEventInput!
  ): StepEvent!

  # Edit asterisms, adding or deleting targets, in (potentially) multiple
  # observations at once.
  #         
  bulkEditAsterism(
    # Bulk edit asterism
    input: BulkEditAsterismInput!
  ): [Observation!]!

  # Edit constraint sets, setting image quality or elevation ranges etc,
  # in (potentially) multiple observations at once.
  #         
  bulkEditConstraintSet(
    # Bulk edit constraintSet
    input: BulkEditConstraintSetInput!
  ): [Observation!]!

  # Edit the instrument selection and observing mode along with its basic
  # configuration in (potentially) multiple observations at once.
  #         
  bulkEditScienceMode(
    # Bulk edit scienceMode
    input: BulkEditScienceModeInput!
  ): [Observation!]!

  # Edit science requirements in (potentially) multiple observations at
  # once.
  #         
  bulkEditScienceRequirements(
    # Bulk edit scienceRequirements
    input: BulkEditScienceRequirementsInput!
  ): [Observation!]!

  # Edit target environments, setting an explicit base position or the
  # asterism, in (potentially) multiple observations at once.
  #         
  bulkEditTargetEnvironment(
    # Bulk edit targetEnvironment
    input: BulkEditTargetEnvironmentInput!
  ): [Observation!]!
  cloneObservation(
    # Observation clone parameters
    input: CloneObservationInput!
  ): Observation!

  # Makes a copy of an existing target, setting it to unobserved and to PRESENT. 
  # If observationIds is specified, the clone will replace the existing target in
  # those observations
  cloneTarget(
    # The existing target's id
    existingTargetId: TargetId!

    # The new target clone's id (will be generated if not supplied)
    suggestedCloneId: TargetId

    # Observation IDs
    observationIds: [ObservationId!]
  ): Target!
  createObservation(
    # Observation description
    input: CreateObservationInput!
  ): Observation
  createProgram(
    # Program description
    input: CreateProgramInput!
  ): Program

  # Creates a new target according to the provided parameters.  Only one of sidereal or nonsidereal may be specified.
  createTarget(
    # Program ID
    programId: ProgramId!

    # Target description.  One (and only one) of sidereal or nonsidereal must be specified.
    input: CreateTargetInput!
  ): Target!
  deleteObservation(
    # Observation ID
    observationId: ObservationId!
  ): Observation!

  # Marks the target as DELETED.  Use undeleteTarget to retrieve it.
  deleteTarget(
    # Target ID
    targetId: TargetId!
  ): Target!

  # Record a new step
  recordGmosNorthStep(
    # GmosNorth step configuration parameters
    input: GmosNorthStepRecordInput!
  ): GmosNorthStepRecord!

  # Record a new visit
  recordGmosNorthVisit(
    # VisitRecord creation parameters
    input: GmosNorthVisitRecordInput!
  ): GmosNorthVisitRecord!

  # Record a new step
  recordGmosSouthStep(
    # GmosSouth step configuration parameters
    input: GmosSouthStepRecordInput!
  ): GmosSouthStepRecord!

  # Record a new visit
  recordGmosSouthVisit(
    # VisitRecord creation parameters
    input: GmosSouthVisitRecordInput!
  ): GmosSouthVisitRecord!
  setDatasetQaState(
    # Observation ID
    observationId: ObservationId!

    # Step ID
    stepId: StepId

    # Dataset index
    index: PosInt

    # Dataset QA State
    qaState: DatasetQaState!
  ): [Dataset!]!
  undeleteObservation(
    # Observation ID
    observationId: ObservationId!
  ): Observation!

  # Marks the target as PRESENT.
  undeleteTarget(
    # Target ID
    targetId: TargetId!
  ): Target!
  updateObservation(
    # Edit observation
    input: EditObservationInput!
  ): Observation!
  updateProgram(
    # Edit program
    input: EditProgramInput!
  ): Program!

  # Edits an existing target
  updateTarget(
    # Parameters for editing an existing target. Nonsidereal edits are ignored for sidereal targets and vice versa.
    input: EditTargetInput!
  ): Target!
}

# A String value that cannot be empty
scalar NonEmptyString

type Nonsidereal {
  # Human readable designation that discriminates among ephemeris keys of the same type.
  des: String!

  # Nonsidereal target lookup type.
  keyType: EphemerisKeyType!

  # Synthesis of `keyType` and `des`
  key: String!
}

# Nonsidereal target parameters.  Supply `keyType` and `des` or `key`
input NonsiderealInput {
  # The keyType field must be either specified or skipped altogether.  It cannot be unset with a null value.
  keyType: EphemerisKeyType

  # The des field must be either specified or skipped altogether.  It cannot be unset with a null value.
  des: NonEmptyString

  # The key field must be either specified or skipped altogether.  It cannot be unset with a null value.
  key: NonEmptyString
}

# Observation operational/active status options
enum ObsActiveStatus {
  # ObsActiveStatus Active
  ACTIVE

  # ObsActiveStatus Inactive
  INACTIVE
}

type Observation {
  # Observation ID
  id: ObservationId!

  # DELETED or PRESENT
  existence: Existence!

  # Observation title generated from id and targets
  title: String!

  # User-supplied observation-identifying detail information
  subtitle: NonEmptyString

  # Observation status
  status: ObsStatus!

  # Observation operational status
  activeStatus: ObsActiveStatus!

  # Observation planned time calculation.
  plannedTime: PlannedTimeSummary!

  # The program that contains this observation
  program(
    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): Program!

  # The observation's target(s)
  targetEnvironment: TargetEnvironment!

  # The constraint set for the observation
  constraintSet: ConstraintSet!

  # The top level science requirements
  scienceRequirements(
    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ScienceRequirements!

  # The science configuration
  scienceMode(
    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ScienceMode

  # ITC execution results
  itc(
    # Whether to use cached results (true) or ignore the cache and make a remote ITC call (false).
    useCache: Boolean! = true
  ): ItcSuccess

  # Manual instrument configuration
  manualConfig: ManualConfig

  # Execution sequence and runtime artifacts
  execution: Execution!
}

# Matching observations
type ObservationConnection {
  # The nodes in all the edges from the current page
  nodes: [Observation!]!

  # Edges in the current page
  edges: [ObservationEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# An observation and its cursor
type ObservationEdge {
  # ObservationEdge element
  node: Observation!

  # ObservationEdge element cursor
  cursor: Cursor!
}

# Event sent when a new object is created or updated
type ObservationEdit implements Event {
  # Type of edit
  editType: EditType!

  # Edited object
  value: Observation!
  id: Long!
}

# ObservationId id formatted as `o-[1-9a-f][0-9a-f]*`
scalar ObservationId

# Observation status options
enum ObsStatus {
  # ObsStatus New
  NEW

  # ObsStatus Included
  INCLUDED

  # ObsStatus Proposed
  PROPOSED

  # ObsStatus Approved
  APPROVED

  # ObsStatus ForReview
  FOR_REVIEW

  # ObsStatus Ready
  READY

  # ObsStatus Ongoing
  ONGOING

  # ObsStatus Observed
  OBSERVED
}

type Offset {
  # Offset in p
  p: p!

  # Offset in q
  q: q!
}

# Offset component (p or q) input parameters. Choose one angle units definition.
input OffsetComponentInput {
  # Angle in µas
  microarcseconds: Long

  # Angle in mas
  milliarcseconds: BigDecimal

  # Angle in arcsec
  arcseconds: BigDecimal
}

# Offset input.  Define offset in p and q.
input OffsetInput {
  # Offset in p
  p: OffsetComponentInput!

  # Offset in q
  q: OffsetComponentInput!
}

type p {
  # p offset in µas
  microarcseconds: Long!

  # p offset in mas
  milliarcseconds: BigDecimal!

  # p offset in arcsec
  arcseconds: BigDecimal!
}

# Information that supports paging through a list of elements
type PageInfo {
  # Cursor pointing to the first element in the result set, if any
  startCursor: Cursor

  # Cursor pointing to the last element in the result set, if any
  endCursor: Cursor

  # Whether there are any pages left to retrieve
  hasNextPage: Boolean!
}

type Parallax {
  # Parallax in microarcseconds
  microarcseconds: Long!

  # Parallax in milliarcseconds
  milliarcseconds: BigDecimal!
}

# Decimal value in Parallax
input ParallaxDecimalInput {
  # decimal value in associated units
  value: BigDecimal!

  # units for associated value
  units: ParallaxUnits!
}

# Parallax, choose one of the available units
input ParallaxInput {
  microarcseconds: Long
  milliarcseconds: BigDecimal
  fromLong: ParallaxLongInput
  fromDecimal: ParallaxDecimalInput
}

# Integral value in Parallax
input ParallaxLongInput {
  # integral value in associated units
  value: Long!

  # units for associated value
  units: ParallaxUnits!
}

# Unit options for parallax values
enum ParallaxUnits {
  # ParallaxUnits Microarcseconds
  MICROARCSECONDS

  # ParallaxUnits Milliarcseconds
  MILLIARCSECONDS
}

# Planetary nebula spectrum
enum PlanetaryNebulaSpectrum {
  # PlanetaryNebulaSpectrum NGC7009
  NGC7009

  # PlanetaryNebulaSpectrum IC5117
  IC5117
}

# Planet spectrum
enum PlanetSpectrum {
  # PlanetSpectrum Mars
  MARS

  # PlanetSpectrum Jupiter
  JUPITER

  # PlanetSpectrum Saturn
  SATURN

  # PlanetSpectrum Uranus
  URANUS

  # PlanetSpectrum Neptune
  NEPTUNE
}

# Time estimates for executing this configuration
type PlannedTime {
  # Estimated setup time
  setup: Duration!

  # Estimated acquisition time for each atom
  acquisition: [StepTime!]!

  # Total estimated acquisition time
  acquisitionTotal: StepTime!

  # Estimated science time for each atom
  science: [StepTime!]!

  # Total estimated science time
  scienceTotal: StepTime!

  # Total planned time across acquisition and science
  total: Duration!
}

type PlannedTimeSummary {
  # The portion of planned time that will be charged
  pi: Duration!

  # The portion of planned time that will not be charged
  uncharged: Duration!

  # The total estimated execution time
  execution: Duration!
}

# A `BigDecimal` greater than 0
scalar PosBigDecimal

# An `Int` in the range from 1 to `Int.MaxValue`
scalar PosInt

type Program {
  # Program ID
  id: ProgramId!

  # DELETED or PRESENT
  existence: Existence!

  # Program name
  name: NonEmptyString

  # All observations associated with the program (needs pagination).
  observations(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ObservationConnection!

  # Program planned time calculation.
  plannedTime(
    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): PlannedTimeSummary!
}

# Programs in the current page
type ProgramConnection {
  # The nodes in all the edges from the current page
  nodes: [Program!]!

  # Edges in the current page
  edges: [ProgramEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# A Program node and its cursor
type ProgramEdge {
  # ProgramEdge element
  node: Program!

  # ProgramEdge element cursor
  cursor: Cursor!
}

# Event sent when a new object is created or updated
type ProgramEdit implements Event {
  # Type of edit
  editType: EditType!

  # Edited object
  value: Program!
  id: Long!
}

# ProgramId id formatted as `p-[1-9a-f][0-9a-f]*`
scalar ProgramId

type ProperMotion {
  # Proper motion in RA
  ra: ProperMotionRA!

  # Proper motion in declination
  dec: ProperMotionDeclination!
}

# Decimal value in ProperMotionComponent
input ProperMotionComponentDecimalInput {
  # decimal value in associated units
  value: BigDecimal!

  # units for associated value
  units: ProperMotionComponentUnits!
}

# Proper motion component, choose one of the available units
input ProperMotionComponentInput {
  microarcsecondsPerYear: Long
  milliarcsecondsPerYear: BigDecimal
  fromLong: ProperMotionComponentLongInput
  fromDecimal: ProperMotionComponentDecimalInput
}

# Integral value in ProperMotionComponent
input ProperMotionComponentLongInput {
  # integral value in associated units
  value: Long!

  # units for associated value
  units: ProperMotionComponentUnits!
}

# Unit options for proper motion components (RA and Dec)
enum ProperMotionComponentUnits {
  # ProperMotionComponentUnits MicroarcsecondsPerYear
  MICROARCSECONDS_PER_YEAR

  # ProperMotionComponentUnits MilliarcsecondsPerYear
  MILLIARCSECONDS_PER_YEAR
}

type ProperMotionDeclination {
  # Proper motion in properMotion μas/year
  microarcsecondsPerYear: Long!

  # Proper motion in properMotion mas/year
  milliarcsecondsPerYear: BigDecimal!
}

# Proper motion, choose one of the available units
input ProperMotionInput {
  ra: ProperMotionComponentInput!
  dec: ProperMotionComponentInput!
}

type ProperMotionRA {
  # Proper motion in properMotion μas/year
  microarcsecondsPerYear: Long!

  # Proper motion in properMotion mas/year
  milliarcsecondsPerYear: BigDecimal!
}

type q {
  # q offset in µas
  microarcseconds: Long!

  # q offset in mas
  milliarcseconds: BigDecimal!

  # q offset in arcsec
  arcseconds: BigDecimal!
}

# Quasar spectrum
enum QuasarSpectrum {
  # QuasarSpectrum QS0
  QS0

  # QuasarSpectrum QS02
  QS02
}

type Query {
  # All science targets (if any) for the given observation (or environment)
  asterism(
    # Observation ID
    observationId: ObservationId!

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): [Target!]!

  # Observations grouped by commonly held science asterisms
  asterismGroup(
    # Program ID
    programId: ProgramId!

    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): AsterismGroupConnection!

  # Observations grouped by commonly held constraints
  constraintSetGroup(
    # Program ID
    programId: ProgramId!

    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ConstraintSetGroupConnection!

  # Select the dataset associated with the given observation, step, and index
  dataset(
    # Observation ID
    observationId: ObservationId!

    # Step ID
    stepId: StepId!

    # Dataset index
    index: PosInt!
  ): Dataset

  # Select all datasets associated with a step or observation
  datasets(
    # Observation ID
    observationId: ObservationId!

    # Step ID
    stepId: StepId

    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor
  ): DatasetConnection!

  # The first (or only) science target (if any) for the given observation.  This
  # will essentially pick a random target from the observation's asterism and is
  # meant as a convenience when there is only one target.
  firstScienceTarget(
    # Observation ID
    observationId: ObservationId!

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): Target

  # Returns the observation with the given id, if any.
  observation(
    # Observation ID
    observationId: ObservationId!

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): Observation

  # Returns all observations associated with the given ids or program, or all observations if neither is specified.
  observations(
    # (Optional) listing of specific observations to retrieve
    observationIds: [ObservationId!]

    # (Optional) program whose observations are sought
    programId: ProgramId

    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ObservationConnection!

  # Returns the program with the given id, if any.
  program(
    # Program ID
    programId: ProgramId!

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): Program

  # Pages through all requested programs (or all programs if no ids are given).
  programs(
    # (Optional) listing of programs to retrieve (all programs if empty)
    programIds: [ProgramId!]

    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ProgramConnection!

  # Observations grouped by commonly held science mode
  scienceModeGroup(
    # Program ID
    programId: ProgramId!

    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ScienceModeGroupConnection!

  # Observations grouped by commonly held science requirements
  scienceRequirementsGroup(
    # Program ID
    programId: ProgramId!

    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ScienceRequirementsGroupConnection!

  # All the science targets associated with a given program or specific observations
  scienceTargets(
    # Program ID
    programId: ProgramId

    # Observation IDs
    observationIds: [ObservationId!]

    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): TargetConnection!

  # Retrieves the target with the given id, if it exists
  target(
    # Target ID
    targetId: TargetId!

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): Target

  # Target environment for the given observation (or environment id)
  targetEnvironment(
    # Observation ID
    observationId: ObservationId!
  ): TargetEnvironment

  # Observations grouped by common target environment
  targetEnvironmentGroup(
    # Program ID
    programId: ProgramId!

    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): TargetEnvironmentGroupConnection!

  # Observations grouped by commonly held targets
  targetGroup(
    # Program ID
    programId: ProgramId!

    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): TargetGroupConnection!
}

type RadialVelocity {
  # Radial velocity in cm/s
  centimetersPerSecond: Long!

  # Radial velocity in m/s
  metersPerSecond: BigDecimal!

  # Radial velocity in km/s
  kilometersPerSecond: BigDecimal!
}

# Decimal value in RadialVelocity
input RadialVelocityDecimalInput {
  # decimal value in associated units
  value: BigDecimal!

  # units for associated value
  units: RadialVelocityUnits!
}

# Radial velocity, choose one of the available units
input RadialVelocityInput {
  centimetersPerSecond: Long
  metersPerSecond: BigDecimal
  kilometersPerSecond: BigDecimal
  fromLong: RadialVelocityLongInput
  fromDecimal: RadialVelocityDecimalInput
}

# Integral value in RadialVelocity
input RadialVelocityLongInput {
  # integral value in associated units
  value: Long!

  # units for associated value
  units: RadialVelocityUnits!
}

# Unit options for radial velocity values
enum RadialVelocityUnits {
  # RadialVelocityUnits CentimetersPerSecond
  CENTIMETERS_PER_SECOND

  # RadialVelocityUnits MetersPerSecond
  METERS_PER_SECOND

  # RadialVelocityUnits KilometersPerSecond
  KILOMETERS_PER_SECOND
}

type RightAscension {
  # Right Ascension (RA) in HH:MM:SS.SSS format
  hms: HmsString!

  # Right Ascension (RA) in hours
  hours: BigDecimal!

  # Right Ascension (RA) in degrees
  degrees: BigDecimal!

  # Right Ascension (RA) in µas
  microarcseconds: Long!
}

# Decimal value in RightAscension
input RightAscensionDecimalInput {
  # decimal value in associated units
  value: BigDecimal!

  # units for associated value
  units: RightAscensionUnits!
}

# Right Ascension, choose one of the available units
input RightAscensionInput {
  microarcseconds: Long
  degrees: BigDecimal
  hours: BigDecimal
  hms: HmsString
  fromLong: RightAscensionLongInput
  fromDecimal: RightAscensionDecimalInput
}

# Integral value in RightAscension
input RightAscensionLongInput {
  # integral value in associated units
  value: Long!

  # units for associated value
  units: RightAscensionUnits!
}

# Unit options for RightAscension values
enum RightAscensionUnits {
  # RightAscensionUnits Microarcseconds
  MICROARCSECONDS

  # RightAscensionUnits Degrees
  DEGREES

  # RightAscensionUnits Hours
  HOURS
}

# Science step
type Science implements StepConfig {
  # Offset
  offset: Offset!

  # Step type
  stepType: StepType!
}

# Base science mode
type ScienceMode {
  # Instrument
  instrument: InstrumentType!

  # Mode type
  mode: ConfigurationModeType!

  # GMOS North Long Slit mode
  gmosNorthLongSlit: GmosNorthLongSlit

  # GMOS South Long Slit mode
  gmosSouthLongSlit: GmosSouthLongSlit
}

type ScienceModeGroup {
  # IDs of observations that use the same constraints
  observationIds: [ObservationId!]!

  # Observations that use this constraint set
  observations(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ObservationConnection!

  # Commonly held value across the observations
  scienceMode: ScienceMode
}

# Observations grouped by common properties
type ScienceModeGroupConnection {
  # The nodes in all the edges from the current page
  nodes: [ScienceModeGroup!]!

  # Edges in the current page
  edges: [ScienceModeGroupEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# An observation group and its cursor
type ScienceModeGroupEdge {
  # ScienceModeGroupEdge element
  node: ScienceModeGroup!

  # ScienceModeGroupEdge element cursor
  cursor: Cursor!
}

# Edit or create an observation's science mode
input ScienceModeInput {
  # The gmosNorthLongSlit field must be either specified or skipped altogether.  It cannot be unset with a null value.
  gmosNorthLongSlit: GmosNorthLongSlitInput

  # The gmosSouthLongSlit field must be either specified or skipped altogether.  It cannot be unset with a null value.
  gmosSouthLongSlit: GmosSouthLongSlitInput
}

# Mode Spectroscopy/Imaging
enum ScienceRequirementMode {
  # ScienceRequirementMode Imaging
  IMAGING

  # ScienceRequirementMode Spectroscopy
  SPECTROSCOPY
}

type ScienceRequirements {
  # Science requirement mode
  mode: ScienceRequirementMode!

  # Spectroscopy requirements
  spectroscopy: SpectroscopyScienceRequirements!
}

type ScienceRequirementsGroup {
  # IDs of observations that use the same constraints
  observationIds: [ObservationId!]!

  # Observations that use this constraint set
  observations(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ObservationConnection!

  # Commonly held value across the observations
  scienceRequirements: ScienceRequirements!
}

# Observations grouped by common properties
type ScienceRequirementsGroupConnection {
  # The nodes in all the edges from the current page
  nodes: [ScienceRequirementsGroup!]!

  # Edges in the current page
  edges: [ScienceRequirementsGroupEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# An observation group and its cursor
type ScienceRequirementsGroupEdge {
  # ScienceRequirementsGroupEdge element
  node: ScienceRequirementsGroup!

  # ScienceRequirementsGroupEdge element cursor
  cursor: Cursor!
}

# Edit science requirements
input ScienceRequirementsInput {
  # The mode field must be either specified or skipped altogether.  It cannot be unset with a null value.
  mode: ScienceRequirementMode

  # The spectroscopy field must be either specified or skipped altogether.  It cannot be unset with a null value.
  spectroscopy: SpectroscopyScienceRequirementsInput
}

# Sequence-level command
enum SequenceCommand {
  # SequenceCommand ABORT
  ABORT

  # SequenceCommand CONTINUE
  CONTINUE

  # SequenceCommand PAUSE
  PAUSE

  # SequenceCommand SLEW
  SLEW

  # SequenceCommand START
  START

  # SequenceCommand STOP
  STOP
}

# Sequence-level events.  As commands are issued to execute a sequence, corresponding events are generated.
type SequenceEvent implements ExecutionEvent {
  # Identifies the observation to which the event refers
  location: SequenceEventLocation!

  # Sequence event data
  payload: SequenceEventPayload!

  # Event id
  id: ExecutionEventId!

  # Associated visit
  visitId: VisitId!

  # Observation whose execution produced this event
  observation: Observation!

  # Time at which this event was received
  received: Instant!
}

# Sequence ExecutionEvents in the current page
type SequenceEventConnection {
  # The nodes in all the edges from the current page
  nodes: [SequenceEvent!]!

  # Edges in the current page
  edges: [SequenceEventEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# A sequence ExecutionEvent and its cursor
type SequenceEventEdge {
  # SequenceEventEdge element
  node: SequenceEvent!

  # SequenceEventEdge element cursor
  cursor: Cursor!
}

# Sequence event location, i.e., to which observation the event refers.
type SequenceEventLocation {
  # Observation containing the sequence
  observationId: ObservationId!
}

# SequenceEvent location parameters
input SequenceEventLocationInput {
  observationId: ObservationId!
}

# Sequence event data
type SequenceEventPayload {
  # Sequence command
  command: SequenceCommand!
}

# SequenceEvent payload creation parameters
input SequenceEventPayloadInput {
  command: SequenceCommand!
}

# Type of sequence, acquisition or science
enum SequenceType {
  # SequenceType ACQUISITION
  ACQUISITION

  # SequenceType SCIENCE
  SCIENCE
}

type Sidereal {
  # Right ascension at epoch
  ra: RightAscension!

  # Declination at epoch
  dec: Declination!

  # Epoch, time of base observation
  epoch: EpochString!

  # Proper motion per year in right ascension and declination
  properMotion: ProperMotion

  # Radial velocity
  radialVelocity: RadialVelocity

  # Parallax
  parallax: Parallax

  # Catalog info, if any, describing from where the information in this target was obtained
  catalogInfo: CatalogInfo
}

# Sidereal target edit parameters
input SiderealInput {
  # The ra field must be either specified or skipped altogether.  It cannot be unset with a null value.
  ra: RightAscensionInput

  # The dec field must be either specified or skipped altogether.  It cannot be unset with a null value.
  dec: DeclinationInput

  # The epoch field must be either specified or skipped altogether.  It cannot be unset with a null value.
  epoch: EpochString

  # The properMotion field may be unset by assigning a null value, or ignored by skipping it altogether
  properMotion: ProperMotionInput

  # The radialVelocity field may be unset by assigning a null value, or ignored by skipping it altogether
  radialVelocity: RadialVelocityInput

  # The parallax field may be unset by assigning a null value, or ignored by skipping it altogether
  parallax: ParallaxInput

  # The catalogInfo field may be unset by assigning a null value, or ignored by skipping it altogether
  catalogInfo: CatalogInfoInput
}

# Sky background
enum SkyBackground {
  # SkyBackground Darkest
  DARKEST

  # SkyBackground Dark
  DARK

  # SkyBackground Gray
  GRAY

  # SkyBackground Bright
  BRIGHT
}

# Source profile, exactly one of the fields will be defined
type SourceProfile {
  # point source, integrated units
  point: SpectralDefinitionIntegrated

  # uniform source, surface units
  uniform: SpectralDefinitionSurface

  # gaussian source, integrated units
  gaussian: GaussianSource
}

# Create or edit a source profile.  Exactly one of "point", "uniform" or "gaussian" is required.
input SourceProfileInput {
  point: SpectralDefinitionIntegratedInput
  uniform: SpectralDefinitionSurfaceInput
  gaussian: GaussianInput
}

# Spectral definition integrated.  Exactly one of the fields will be defined.
type SpectralDefinitionIntegrated {
  # Band normalized spectral definition
  bandNormalized: BandNormalizedIntegrated

  # Emission lines spectral definition
  emissionLines: EmissionLinesIntegrated
}

# Spectral definition input with integrated units.  Specify exactly one of "bandNormalized" or "emissionLines" 
input SpectralDefinitionIntegratedInput {
  bandNormalized: BandNormalizedIntegratedInput
  emissionLines: EmissionLinesIntegratedInput
}

# Spectral definition surface.  Exactly one of the fields will be defined.
type SpectralDefinitionSurface {
  # Band normalized spectral definition
  bandNormalized: BandNormalizedSurface

  # Emission lines spectral definition
  emissionLines: EmissionLinesSurface
}

# Spectral definition input with surface units.  Specify exactly one of "bandNormalized" or "emissionLines" 
input SpectralDefinitionSurfaceInput {
  bandNormalized: BandNormalizedSurfaceInput
  emissionLines: EmissionLinesSurfaceInput
}

# Spectroscopy capabilities Nod&Shuffle/Polarimetry/Corongraphy
enum SpectroscopyCapabilities {
  # SpectroscopyCapabilities NodAndShuffle
  NOD_AND_SHUFFLE

  # SpectroscopyCapabilities Polarimetry
  POLARIMETRY

  # SpectroscopyCapabilities Coronagraphy
  CORONAGRAPHY
}

type SpectroscopyScienceRequirements {
  # Requested central wavelength
  wavelength: Wavelength

  # Requested resolution
  resolution: PosInt

  # Requested signal to noise ratio
  signalToNoise: PosBigDecimal

  # Requested wavelength for the requested signal to noise
  signalToNoiseAt: Wavelength

  # Wavelength range
  wavelengthCoverage: Wavelength

  # Focal plane choice
  focalPlane: FocalPlane

  # Focal plane angle
  focalPlaneAngle: focalPlaneAngle

  # Spectroscopy Capabilities
  capabilities: SpectroscopyCapabilities
}

# Edit or create spectroscopy science requirements
input SpectroscopyScienceRequirementsInput {
  # The wavelength field may be unset by assigning a null value, or ignored by skipping it altogether
  wavelength: WavelengthInput

  # The resolution field may be unset by assigning a null value, or ignored by skipping it altogether
  resolution: Int

  # The signalToNoise field may be unset by assigning a null value, or ignored by skipping it altogether
  signalToNoise: BigDecimal

  # The signalToNoiseAt field may be unset by assigning a null value, or ignored by skipping it altogether
  signalToNoiseAt: WavelengthInput

  # The wavelengthCoverage field may be unset by assigning a null value, or ignored by skipping it altogether
  wavelengthCoverage: WavelengthInput

  # The focalPlane field may be unset by assigning a null value, or ignored by skipping it altogether
  focalPlane: FocalPlane

  # The focalPlaneAngle field may be unset by assigning a null value, or ignored by skipping it altogether
  focalPlaneAngle: FocalPlaneAngleInput

  # The capabilities field may be unset by assigning a null value, or ignored by skipping it altogether
  capabilities: SpectroscopyCapabilities
}

# Stellar library spectrum
enum StellarLibrarySpectrum {
  # StellarLibrarySpectrum O5V
  O5_V

  # StellarLibrarySpectrum O8III
  O8_III

  # StellarLibrarySpectrum B0V
  B0_V

  # StellarLibrarySpectrum B5_7V
  B5_7_V

  # StellarLibrarySpectrum B5III
  B5_III

  # StellarLibrarySpectrum B5I
  B5_I

  # StellarLibrarySpectrum A0V
  A0_V

  # StellarLibrarySpectrum A0III
  A0_III

  # StellarLibrarySpectrum A0I
  A0_I

  # StellarLibrarySpectrum A5V
  A5_V

  # StellarLibrarySpectrum A5III
  A5_III

  # StellarLibrarySpectrum F0V
  F0_V

  # StellarLibrarySpectrum F0III
  F0_III

  # StellarLibrarySpectrum F0I
  F0_I

  # StellarLibrarySpectrum F5V
  F5_V

  # StellarLibrarySpectrum F5V_w
  F5_V_W

  # StellarLibrarySpectrum F6V_r
  F6_V_R

  # StellarLibrarySpectrum F5III
  F5_III

  # StellarLibrarySpectrum F5I
  F5_I

  # StellarLibrarySpectrum G0V
  G0_V

  # StellarLibrarySpectrum G0V_w
  G0_V_W

  # StellarLibrarySpectrum G0V_r
  G0_V_R

  # StellarLibrarySpectrum G0III
  G0_III

  # StellarLibrarySpectrum G0I
  G0_I

  # StellarLibrarySpectrum G2V
  G2_V

  # StellarLibrarySpectrum G5V
  G5_V

  # StellarLibrarySpectrum G5V_w
  G5_V_W

  # StellarLibrarySpectrum G5V_r
  G5_V_R

  # StellarLibrarySpectrum G5III
  G5_III

  # StellarLibrarySpectrum G5III_w
  G5_III_W

  # StellarLibrarySpectrum G5III_r
  G5_III_R

  # StellarLibrarySpectrum G5I
  G5_I

  # StellarLibrarySpectrum K0V
  K0_V

  # StellarLibrarySpectrum K0V_r
  K0_V_R

  # StellarLibrarySpectrum K0III
  K0_III

  # StellarLibrarySpectrum K0III_w
  K0_III_W

  # StellarLibrarySpectrum K0III_r
  K0_III_R

  # StellarLibrarySpectrum K0_1II
  K0_1_II

  # StellarLibrarySpectrum K4V
  K4_V

  # StellarLibrarySpectrum K4III
  K4_III

  # StellarLibrarySpectrum K4III_w
  K4_III_W

  # StellarLibrarySpectrum K4III_r
  K4_III_R

  # StellarLibrarySpectrum K4I
  K4_I

  # StellarLibrarySpectrum M0V
  M0_V

  # StellarLibrarySpectrum M0III
  M0_III

  # StellarLibrarySpectrum M3V
  M3_V

  # StellarLibrarySpectrum M3III
  M3_III

  # StellarLibrarySpectrum M6V
  M6_V

  # StellarLibrarySpectrum M6III
  M6_III

  # StellarLibrarySpectrum M9III
  M9_III
}

# Sequence step
interface Step {
  # Step id
  id: StepId!

  # Whether to pause before the execution of this step
  breakpoint: Breakpoint!

  # The sequence step itself
  stepConfig: StepConfig!

  # Time estimate for this step's execution
  time: StepTime!
}

# Step (bias, dark, gcal, science, etc.)
interface StepConfig {
  # Step type
  stepType: StepType!
}

# Step-level events.  The execution of a single step will generate multiple events.
type StepEvent implements ExecutionEvent {
  # Identifies the step to which the event refers
  location: StepEventLocation!

  # Step event data including the stage of execution through which it is passing.
  payload: StepEventPayload!

  # Event id
  id: ExecutionEventId!

  # Associated visit
  visitId: VisitId!

  # Observation whose execution produced this event
  observation: Observation!

  # Time at which this event was received
  received: Instant!
}

# Step ExecutionEvents in the current page
type StepEventConnection {
  # The nodes in all the edges from the current page
  nodes: [StepEvent!]!

  # Edges in the current page
  edges: [StepEventEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# A step ExecutionEvent and its cursor
type StepEventEdge {
  # StepEventEdge element
  node: StepEvent!

  # StepEventEdge element cursor
  cursor: Cursor!
}

# Step event location, i.e., to which step the event refers
type StepEventLocation {
  # Observation containing the step
  observationId: ObservationId!

  # The step id itself
  stepId: StepId!
}

# StepEvent location parameters
input StepEventLocationInput {
  observationId: ObservationId!
  stepId: StepId!
}

# Step event data
type StepEventPayload {
  # Sequence type
  sequenceType: SequenceType!

  # Step execution stage
  stage: StepStage!
}

# StepEvent payload parameters
input StepEventPayloadInput {
  sequenceType: SequenceType!
  stage: StepStage!
}

# StepId id formatted as `s-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}`
scalar StepId

# Step QA State
enum StepQaState {
  # StepQaState Pass
  PASS

  # StepQaState Fail
  FAIL
}

# Execution stage or phase of an individual step
enum StepStage {
  # StepStage END_CONFIGURE
  END_CONFIGURE

  # StepStage END_OBSERVE
  END_OBSERVE

  # StepStage END_STEP
  END_STEP

  # StepStage START_CONFIGURE
  START_CONFIGURE

  # StepStage START_OBSERVE
  START_OBSERVE

  # StepStage START_STEP
  START_STEP
}

# Time required for a step or steps, categorized according to use
type StepTime {
  # Time spent making configuration changes
  configChange: Duration!

  # Time spent collecting photons
  exposure: Duration!

  # Time spent reading out the detector
  readout: Duration!

  # Time spent writing the dataset file
  write: Duration!

  # Total time across all categories
  total: Duration!
}

# Step type
enum StepType {
  # StepType Bias
  BIAS

  # StepType Dark
  DARK

  # StepType Gcal
  GCAL

  # StepType Science
  SCIENCE

  # StepType SmartGcal
  SMART_GCAL
}

type Subscription {
  #
  # Subscribes to an event that is generated whenever a(n) observation is
  # created or updated.  If a(n) observation id is provided, the event is only
  # generated for edits to that particular observation.  If a program id is
  # provided then the event must correspond to a(n) observation referenced by
  # that program.
  #
  observationEdit(
    # Observation ID
    observationId: ObservationId

    # Program ID
    programId: ProgramId
  ): ObservationEdit!

  #
  # Subscribes to an event that is generated whenever a program is created
  # or edited. A particular program id may be provided to limit events to
  # that program.
  #
  programEdit(
    # Program ID
    programId: ProgramId
  ): ProgramEdit!

  #
  # Subscribes to an event that is generated whenever a(n) target is
  # created or updated.  If a(n) target id is provided, the event is only
  # generated for edits to that particular target.  If a program id is
  # provided then the event must correspond to a(n) target referenced by
  # that program.
  #
  targetEdit(
    # Target ID
    targetId: TargetId

    # Program ID
    programId: ProgramId
  ): TargetEdit!
}

# Target description
type Target {
  # Target ID
  id: TargetId!

  # DELETED or PRESENT
  existence: Existence!

  # Target name.
  name: NonEmptyString!

  # Program that contains this target
  program(
    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): Program!

  # source profile
  sourceProfile: SourceProfile!

  # Sidereal tracking information, if this is a sidereal target
  sidereal: Sidereal

  # Nonsidereal tracking information, if this is a nonsidereal target
  nonsidereal: Nonsidereal
}

# Targets in the current page
type TargetConnection {
  # The nodes in all the edges from the current page
  nodes: [Target!]!

  # Edges in the current page
  edges: [TargetEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# A Target and its cursor
type TargetEdge {
  # TargetEdge element
  node: Target!

  # TargetEdge element cursor
  cursor: Cursor!
}

# Event sent when a new object is created or updated
type TargetEdit implements Event {
  # Type of edit
  editType: EditType!

  # Edited object
  value: Target!
  id: Long!
}

type TargetEnvironment {
  # All the observation's science targets, if any
  asterism(
    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): [Target!]!

  # First, perhaps only, science target in the asterism
  firstScienceTarget(
    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): Target

  # When set, overrides the default base position of the target group
  explicitBase: Coordinates
}

type TargetEnvironmentGroup {
  # IDs of observations that use the same constraints
  observationIds: [ObservationId!]!

  # Observations that use this constraint set
  observations(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ObservationConnection!

  # Commonly held value across the observations
  targetEnvironment: TargetEnvironment!
}

# Observations grouped by common properties
type TargetEnvironmentGroupConnection {
  # The nodes in all the edges from the current page
  nodes: [TargetEnvironmentGroup!]!

  # Edges in the current page
  edges: [TargetEnvironmentGroupEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# An observation group and its cursor
type TargetEnvironmentGroupEdge {
  # TargetEnvironmentGroupEdge element
  node: TargetEnvironmentGroup!

  # TargetEnvironmentGroupEdge element cursor
  cursor: Cursor!
}

# Target environment editing and creation parameters
input TargetEnvironmentInput {
  # The explicitBase field may be unset by assigning a null value, or ignored by skipping it altogether
  explicitBase: CoordinatesInput
  asterism: [TargetId!]
}

type TargetGroup {
  # IDs of observations that use the same constraints
  observationIds: [ObservationId!]!

  # Observations that use this constraint set
  observations(
    # Retrieve `first` values after the given cursor
    first: Int

    # Retrieve values after the one associated with this cursor
    after: Cursor

    # Set to true to include deleted values
    includeDeleted: Boolean! = false
  ): ObservationConnection!

  # Commonly held value across the observations
  target: Target!
}

# Observations grouped by common properties
type TargetGroupConnection {
  # The nodes in all the edges from the current page
  nodes: [TargetGroup!]!

  # Edges in the current page
  edges: [TargetGroupEdge!]!

  # Count of all nodes in all pages
  totalCount: Int!

  # Paging information
  pageInfo: PageInfo!
}

# An observation group and its cursor
type TargetGroupEdge {
  # TargetGroupEdge element
  node: TargetGroup!

  # TargetGroupEdge element cursor
  cursor: Cursor!
}

# TargetId id formatted as `t-[1-9a-f][0-9a-f]*`
scalar TargetId

# Un-normalized spectral energy distribution.  Exactly one of the definitions will be non-null.
type UnnormalizedSed {
  stellarLibrary: StellarLibrarySpectrum
  coolStar: CoolStarTemperature
  galaxy: GalaxySpectrum
  planet: PlanetSpectrum
  quasar: QuasarSpectrum
  hiiRegion: HiiRegionSpectrum
  planetaryNebula: PlanetaryNebulaSpectrum
  powerLaw: BigDecimal
  blackBodyTempK: PosInt
  fluxDensities: [FluxDensityEntry!]
}

# Un-normalized SED input parameters.  Define one value only.
input UnnormalizedSedInput {
  stellarLibrary: StellarLibrarySpectrum
  coolStar: CoolStarTemperature
  galaxy: GalaxySpectrum
  planet: PlanetSpectrum
  quasar: QuasarSpectrum
  hiiRegion: HiiRegionSpectrum
  planetaryNebula: PlanetaryNebulaSpectrum
  powerLaw: BigDecimal
  blackBodyTempK: PosInt
  fluxDensities: [FluxDensity!]
}

# VisitId id formatted as `v-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}`
scalar VisitId

# Water vapor
enum WaterVapor {
  # WaterVapor VeryDry
  VERY_DRY

  # WaterVapor Dry
  DRY

  # WaterVapor Median
  MEDIAN

  # WaterVapor Wet
  WET
}

type Wavelength {
  # Wavelength in pm
  picometers: Int!

  # Wavelength in Å
  angstroms: BigDecimal!

  # Wavelength in nm
  nanometers: BigDecimal!

  # Wavelength in µm
  micrometers: BigDecimal!
}

# Decimal value in Wavelength
input WavelengthDecimalInput {
  # decimal value in associated units
  value: BigDecimal!

  # units for associated value
  units: WavelengthUnits!
}

# Wavelength, choose one of the available units
input WavelengthInput {
  picometers: Long
  angstroms: BigDecimal
  nanometers: BigDecimal
  micrometers: BigDecimal
  fromLong: WavelengthLongInput
  fromDecimal: WavelengthDecimalInput
}

# Integral value in Wavelength
input WavelengthLongInput {
  # integral value in associated units
  value: Long!

  # units for associated value
  units: WavelengthUnits!
}

# Wavelength units
enum WavelengthUnits {
  # WavelengthUnits Picometers
  PICOMETERS

  # WavelengthUnits Angstroms
  ANGSTROMS

  # WavelengthUnits Nanometers
  NANOMETERS

  # WavelengthUnits Micrometers
  MICROMETERS
}

